# 文件审查管理平台 - 技术文档

## 1. 系统架构设计

### 1.1 总体架构

系统采用前后端分离架构，基于容器化部署。整体架构包含以下核心组件：

```
┌─────────────────────────────────────────────────────────┐
│                       用户浏览器                          │
└─────────────────────────────────────────────────────────┘
                            ↓ HTTPS
┌─────────────────────────────────────────────────────────┐
│                  Nginx (反向代理 + 静态资源)              │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│               Spring Boot (后端API服务)                   │
│  - 认证授权 (Spring Security + JWT)                      │
│  - 业务逻辑 (租户管理、用户管理、审查流程)                 │
│  - 文件处理 (上传、下载、预览)                            │
└─────────────────────────────────────────────────────────┘
          ↓                    ↓                    ↓
┌──────────────────┐  ┌─────────────────┐  ┌──────────────────┐
│  MySQL (3306)    │  │ Redis (6379)    │  │  MinIO (9000)    │
│  - 业务数据      │  │ - 登录锁定      │  │  - 文件存储      │
│  - 租户信息      │  │ - Token缓存     │  │  - 对象存储      │
│  - 用户信息      │  │ - 存储统计      │  │  - 去重存储      │
│  - 任务版本      │  └─────────────────┘  └──────────────────┘
└──────────────────┘
```

**架构特点：**
- **前后端分离**：前端Vue 3 + Element Plus（PC端优先），后端Spring Boot RESTful API
- **多租户架构**：通过tenant_id实现数据隔离
- **容器化部署**：使用Docker Compose编排所有服务
- **对象存储**：MinIO存储文件，支持大文件和高并发
- **缓存优化**：Redis缓存热点数据，提升性能
- **异步处理**：使用RabbitMQ消息队列处理文件复制等耗时任务

### 1.2 前端架构

#### 1.2.1 技术栈

| 技术 | 版本 | 用途 |
|------|------|------|
| Vue | 3.3.4 | 前端核心框架，负责页面渲染和组件化开发 |
| Element Plus | 2.4.0 | UI组件库，提供表格、表单、对话框等常用组件 |
| Vue Router | 4.2.5 | 前端路由管理，实现单页面应用的页面跳转和权限控制 |
| Pinia | 2.1.7 | 状态管理，存储用户登录信息、角色信息等全局状态 |
| Axios | 1.5.0 | HTTP客户端，封装与后端API的交互，支持请求拦截和响应拦截 |
| PDF.js | 3.11.174 | PDF文件在线预览，支持缩放、翻页、旋转等操作 |
| Vite | 4.5.0 | 前端构建工具，提供快速的开发服务器和生产环境打包 |

#### 1.2.2 页面结构

系统根据用户角色提供4种不同的页面架构。整体布局采用经典的后台管理系统布局：
- **顶部区域**：显示系统名称、用户信息、头像下拉菜单（修改密码、退出登录）
- **左侧区域**：固定的功能菜单导航（如"租户管理"、"平台统计"等）
- **右侧区域**：主内容区域，显示具体页面内容

##### 1.2.2.1 平台超级管理员后台

###### 1.2.2.1.1 租户管理模块

- 企业列表页面
  - 顶部操作栏：创建企业按钮
  - 筛选搜索：支持按状态筛选（正常/停用）、按企业名称搜索
  - 表格列：企业名称、联系人、联系电话、用户数（已用/总配额）、存储空间（已用/总配额，带进度条）、状态标签、创建时间、操作列
  - 操作按钮：管理用户（主按钮）、编辑企业、停用/启用、删除
- 企业相关对话框
  - 创建企业对话框
    - 表单字段：企业名称（必填）、联系人姓名（必填）、联系电话（必填）、存储配额GB（默认100）、用户数量配额（默认50）
    - 提交后仅创建租户；管理员信息由后续“企业用户管理”对话框单独维护
  - 编辑企业对话框
    - 表单字段：企业名称（必填）、联系人姓名（必填）、联系电话（必填）、存储配额GB（不能小于已使用量）、用户数量配额（不能小于已创建用户数）
    - 底部按钮：取消、保存
  - 停用企业确认框
    - 提示内容：停用后，该企业下所有用户将无法登录系统，是否确认停用？
    - 按钮：取消、确认停用
  - 启用企业确认框
    - 提示内容：启用后，该企业下所有用户将恢复正常状态，是否确认启用？
    - 按钮：取消、确认启用
  - 删除企业确认框
    - 提示内容：删除企业将同时删除该企业下所有用户、审查任务、文件等数据，操作不可逆，是否确认删除？
    - 按钮：取消、确认删除
- 企业管理员管理
  - 企业用户管理对话框（进入“租户详情”后操作）
    - 对话框标题：{企业名称} - 用户管理
    - 顶部操作：添加管理员按钮
    - 表格列：用户名、真实姓名、手机号、创建时间、操作
    - 操作按钮：编辑、删除
  - 添加/编辑企业管理员对话框
    - 表单字段：用户名（必填，企业内唯一）、真实姓名（必填）、手机号（必填）、初始密码（必填，仅添加时）
    - 底部按钮：取消、提交

###### 1.2.2.1.2 平台统计模块

- 平台统计页面
  - 统计卡片区域（4个卡片横向排列）
    - 租户总数：显示企业租户总数
    - 用户总数：显示所有用户总数
    - 审查任务总数：显示所有审查任务数量
    - 存储使用量：显示平台存储总使用量（带进度条）

##### 1.2.2.2 企业管理员后台

###### 1.2.2.2.1 用户管理模块

- 用户列表页面
  - 顶部操作栏：创建用户按钮
  - 筛选搜索：支持按角色筛选（全部/企业管理员/审查员/普通用户）、按状态筛选（正常/停用）、按用户名搜索
  - 表格列：用户名、真实姓名、角色、手机号、状态标签、创建时间、最后登录时间、操作列
  - 操作按钮：编辑用户、停用/启用、删除
- 用户相关对话框
  - 创建用户对话框
    - 表单字段：用户名（必填，企业内唯一）、真实姓名（必填）、手机号（必填）、角色（必填，下拉选择：企业管理员/审查员/普通用户，可多选审查员和普通用户）、初始密码（必填）
    - 底部按钮：取消、提交
  - 编辑用户对话框
    - 表单字段：用户名（不可修改）、真实姓名（必填）、手机号（必填）、角色（必填，下拉选择：企业管理员/审查员/普通用户，可多选审查员和普通用户）
    - 底部按钮：取消、保存
  - 停用用户确认框
    - 提示内容：停用后，该用户将无法登录系统，是否确认停用？
    - 按钮：取消、确认停用
  - 启用用户确认框
    - 提示内容：启用后，该用户将恢复正常状态，是否确认启用？
    - 按钮：取消、确认启用
  - 删除用户确认框
    - 提示内容：删除用户将同时删除该用户创建的所有审查任务和文件，操作不可逆，是否确认删除？
    - 按钮：取消、确认删除

##### 1.2.2.3 审查员前台

###### 1.2.2.3.1 审查任务模块

- 任务列表页面
  - 页面标题：待审查任务
  - 筛选搜索：支持按当前状态筛选（全部/审查中/已通过/已打回）、按任务名称搜索
  - 任务行显示
    - 展开/收起图标
    - 任务名称
    - 提交人
    - 创建时间
    - 当前版本号
    - 当前状态标签（审查中-黄色、已通过-绿色、已打回-红色）
    - 操作按钮：开始审查（仅当前状态为"审查中"时显示）
  - 展开后显示版本记录列表
    - 版本号（v1、v2、v3...）
    - 提交时间
    - 审查状态标签
    - 审查人（如已审查）
    - 操作：查看详情
  - 底部分页器
- 审查页面
  - 页面标题：审查任务 - [任务名称] - [版本号]
  - 返回按钮：返回任务列表
  - 任务信息区域
    - 任务名称、提交人、版本号、提交时间
  - 提交说明区域（如有填写）
    - 标题：提交说明
    - 内容：提交说明文字
  - 文件预览区域
    - 文件列表：文件名、文件大小、操作（预览、下载）
    - 支持PDF在线预览
  - 审查操作区域
    - 审查结果：单选框（通过/打回）
    - 审查意见：多行文本框（可选）
    - 底部按钮：返回列表、提交审查
  - 提交审查确认框
    - 提示内容：确认提交审查结果吗？提交后不可修改
    - 按钮：取消、确认提交
- 版本详情页面
  - 页面标题：版本详情 - [任务名称] - [版本号]
  - 返回按钮：返回任务列表
  - 基本信息区域
    - 任务名称
    - 提交人
    - 版本号
    - 提交时间
    - 审查状态标签（审查中/已通过/已打回）
  - 提交说明区域（如有填写）
    - 标题：提交说明
    - 内容：提交说明文字
  - 文件列表区域
    - 标题：审查文件
    - 文件列表：文件类型图标、文件名、文件大小、操作（预览、下载）
  - 审查意见区域（如已审查）
    - 标题：审查意见
    - 审查人（本人）
    - 审查时间
    - 审查结果标签（已通过/已打回）
    - 审查意见内容
  - 说明：只读页面，不可修改

##### 1.2.2.4 普通用户前台

###### 1.2.2.4.1 我的任务模块

- 任务列表页面
  - 页面标题：我的审查任务
  - 顶部操作栏：创建审查任务按钮（主按钮）
  - 筛选搜索：支持按当前状态筛选（全部/审查中/已通过/已打回）、按任务名称搜索
  - 任务行显示
    - 展开/收起图标
    - 任务名称
    - 审查员
    - 创建时间
    - 当前版本号
    - 当前状态标签（审查中-黄色、已通过-绿色、已打回-红色）
    - 操作按钮：提交新版本（仅当前状态为"已打回"时显示）
  - 展开后显示版本记录列表
    - 版本号（v1、v2、v3...）
    - 提交时间
    - 审查状态标签
    - 审查人
    - 操作：查看详情
  - 底部分页器
- 创建任务页面
  - 页面标题：创建审查任务
  - 返回按钮：返回列表
  - 版本号显示：v1（固定显示，不可修改）
  - 基本信息区域
    - 任务名称（必填）：单行文本框，企业内唯一
    - 选择审查员（必填）：下拉选择框，单选
  - 提交说明区域
    - 提交说明（可选）：多行文本框
  - 文件上传区域
    - 上传区域：支持拖拽上传、点击选择文件
    - 文件类型限制：仅支持PDF格式（.pdf）
    - 单个文件大小限制：最大200MB
    - 至少上传1个文件
    - 已上传文件列表：显示文件名、文件大小、操作（预览、删除）
  - 底部按钮：取消、创建任务
  - 说明：一步完成，创建任务的同时创建版本v1，任务状态为"审查中"
- 提交新版本页面
  - 页面标题：提交新版本 - [任务名称]
  - 返回按钮：返回任务列表
  - 版本号显示：显示即将创建的新版本号（v2、v3...自动递增）
  - 审查意见展示区域（只读，灰色背景）
    - 标题：审查意见
    - 审查员姓名
    - 审查时间
    - 审查意见内容
  - 文件管理区域
    - 说明：默认带入上一版本的所有文件，可修改
    - 当前文件列表：显示上一版本的文件
    - 操作：预览、更换（选择新文件替换）、删除
    - 添加文件按钮：可追加新文件
    - 文件类型限制：仅支持PDF格式（.pdf）
    - 单个文件大小限制：最大200MB
    - 至少保留1个文件
  - 提交说明区域
    - 提交说明（可选）：多行文本框，提示"可说明根据审查意见做了哪些修改"
  - 底部按钮：取消、提交新版本
  - 提交新版本确认框
    - 提示内容：确认提交新版本吗？
    - 按钮：取消、确认提交
  - 说明：版本号自动递增，审查员保持不变，新版本状态为"审查中"，文件从上一版本复制（独立存储）
- 版本详情页面
  - 页面标题：版本详情 - [任务名称] - [版本号]
  - 返回按钮：返回任务列表
  - 基本信息区域
    - 任务名称
    - 审查员
    - 版本号
    - 提交时间
    - 审查状态标签（审查中/已通过/已打回）
  - 提交说明区域（如有填写）
    - 标题：提交说明
    - 内容：提交说明文字
  - 文件列表区域
    - 标题：审查文件
    - 文件列表：文件类型图标、文件名、文件大小、操作（预览、下载）
  - 审查意见区域（如已审查）
    - 标题：审查意见
    - 审查员
    - 审查时间
    - 审查结果标签（已通过/已打回）
    - 审查意见内容
  - 说明：只读页面，不可修改

#### 1.2.3 代码目录结构

##### 1.2.3.1 前端目录结构

```
frontend/
├── public/                    # 静态资源
│   ├── index.html            # 入口HTML
│   └── favicon.ico           # 网站图标
├── src/
│   ├── api/                  # API接口封装
│   │   ├── auth.js          # 认证相关接口
│   │   ├── tenant.js        # 租户管理接口
│   │   ├── user.js          # 用户管理接口
│   │   ├── task.js          # 审查任务接口
│   │   ├── version.js       # 版本管理接口
│   │   └── file.js          # 文件管理接口
│   ├── assets/              # 资源文件
│   │   ├── images/          # 图片资源
│   │   └── styles/          # 全局样式
│   ├── components/          # 公共组件
│   │   ├── layout/          # 布局组件
│   │   │   ├── TopBar.vue   # 顶部导航栏
│   │   │   ├── SideMenu.vue # 左侧菜单
│   │   │   └── MainLayout.vue # 主布局
│   │   ├── common/          # 通用组件
│   │   │   ├── FileUpload.vue    # 文件上传组件
│   │   │   ├── FilePreview.vue   # 文件预览组件
│   │   │   └── ConfirmDialog.vue # 确认对话框
│   │   └── task/            # 任务相关组件
│   │       ├── TaskList.vue      # 任务列表组件
│   │       └── VersionList.vue   # 版本列表组件
│   ├── router/              # 路由配置
│   │   └── index.js         # 路由定义
│   ├── store/               # 状态管理
│   │   ├── index.js         # Store入口
│   │   ├── modules/         # 模块化Store
│   │   │   ├── auth.js      # 认证状态
│   │   │   ├── user.js      # 用户状态
│   │   │   └── task.js      # 任务状态
│   ├── utils/               # 工具函数
│   │   ├── request.js       # Axios封装
│   │   ├── auth.js          # 认证工具
│   │   └── validator.js     # 表单验证
│   ├── views/               # 页面视图
│   │   ├── login/           # 登录页
│   │   │   └── index.vue
│   │   ├── platform/        # 平台超管页面
│   │   │   ├── tenant/      # 租户管理
│   │   │   └── statistics/  # 平台统计
│   │   ├── admin/           # 企业管理员页面
│   │   │   └── user/        # 用户管理
│   │   ├── reviewer/        # 审查员页面
│   │   │   └── task/        # 审查任务
│   │   └── user/            # 普通用户页面
│   │       └── task/        # 我的任务
│   ├── App.vue              # 根组件
│   └── main.js              # 入口文件
├── .env.development         # 开发环境配置
├── .env.production          # 生产环境配置
├── package.json             # 依赖配置
├── vite.config.js           # Vite配置
└── README.md                # 项目说明
```

##### 1.2.3.2 后端目录结构

```
backend/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── review/
│   │   │           ├── ReviewApplication.java  # 启动类
│   │   │           ├── config/                 # 配置类
│   │   │           │   ├── SecurityConfig.java       # 安全配置
│   │   │           │   ├── MyBatisConfig.java        # MyBatis配置
│   │   │           │   ├── MinioConfig.java          # MinIO配置
│   │   │           │   ├── RedisConfig.java          # Redis配置
│   │   │           │   ├── RabbitMQConfig.java       # RabbitMQ配置
│   │   │           │   └── WebMvcConfig.java         # Web配置
│   │   │           ├── controller/             # 控制器
│   │   │           │   ├── AuthController.java       # 认证控制器
│   │   │           │   ├── TenantController.java     # 租户管理
│   │   │           │   ├── UserController.java       # 用户管理
│   │   │           │   ├── TaskController.java       # 任务管理
│   │   │           │   ├── VersionController.java    # 版本管理
│   │   │           │   └── FileController.java       # 文件管理
│   │   │           ├── service/                # 服务层
│   │   │           │   ├── AuthService.java          # 认证服务
│   │   │           │   ├── TenantService.java        # 租户服务
│   │   │           │   ├── UserService.java          # 用户服务
│   │   │           │   ├── TaskService.java          # 任务服务
│   │   │           │   ├── VersionService.java       # 版本服务
│   │   │           │   └── FileService.java          # 文件服务
│   │   │           ├── mapper/                 # MyBatis Mapper
│   │   │           │   ├── TenantMapper.java         # 租户Mapper
│   │   │           │   ├── UserMapper.java           # 用户Mapper
│   │   │           │   ├── TaskMapper.java           # 任务Mapper
│   │   │           │   ├── VersionMapper.java        # 版本Mapper
│   │   │           │   └── FileMapper.java           # 文件Mapper
│   │   │           ├── entity/                 # 实体类
│   │   │           │   ├── Tenant.java               # 租户实体
│   │   │           │   ├── User.java                 # 用户实体
│   │   │           │   ├── Task.java                 # 任务实体
│   │   │           │   ├── Version.java              # 版本实体
│   │   │           │   └── File.java                 # 文件实体
│   │   │           ├── dto/                    # 数据传输对象
│   │   │           │   ├── request/                  # 请求DTO
│   │   │           │   └── response/                 # 响应DTO
│   │   │           ├── common/                 # 公共类
│   │   │           │   ├── Result.java               # 统一响应结果
│   │   │           │   ├── PageResult.java           # 分页结果
│   │   │           │   └── Constants.java            # 常量定义
│   │   │           ├── exception/              # 异常处理
│   │   │           │   ├── BusinessException.java    # 业务异常
│   │   │           │   └── GlobalExceptionHandler.java # 全局异常处理
│   │   │           ├── security/               # 安全相关
│   │   │           │   ├── JwtUtil.java              # JWT工具类
│   │   │           │   ├── JwtFilter.java            # JWT过滤器
│   │   │           │   └── UserDetailsServiceImpl.java # 用户详情服务
│   │   │           ├── mq/                     # 消息队列
│   │   │           │   ├── producer/                 # 消息生产者
│   │   │           │   │   ├── FileProcessProducer.java   # 文件处理消息生产者
│   │   │           │   │   └── FileCopyProducer.java      # 文件复制消息生产者
│   │   │           │   └── consumer/                 # 消息消费者
│   │   │           │       ├── FileProcessConsumer.java   # 文件处理消息消费者
│   │   │           │       └── FileCopyConsumer.java      # 文件复制消息消费者
│   │   │           └── util/                   # 工具类
│   │   │               ├── MinioUtil.java            # MinIO工具类
│   │   │               ├── RedisUtil.java            # Redis工具类
│   │   │               ├── FileUtil.java             # 文件工具
│   │   │               └── ValidationUtil.java       # 验证工具
│   │   └── resources/
│   │       ├── mapper/                         # MyBatis XML
│   │       │   ├── TenantMapper.xml
│   │       │   ├── UserMapper.xml
│   │       │   ├── TaskMapper.xml
│   │       │   ├── VersionMapper.xml
│   │       │   └── FileMapper.xml
│   │       ├── application.yml                 # 应用配置
│   │       ├── application-dev.yml             # 开发环境配置
│   │       ├── application-prod.yml            # 生产环境配置
│   │       └── logback-spring.xml              # 日志配置
│   └── test/                                   # 测试代码
├── pom.xml                                     # Maven配置
└── README.md                                   # 项目说明
```

### 1.3 后端架构

#### 1.3.1 架构分层

后端采用经典的三层架构：

```
┌─────────────────────────────────────┐
│       Controller层（控制器层）        │
│   - 接收HTTP请求                      │
│   - 参数验证                          │
│   - 调用Service层                     │
│   - 返回JSON响应                      │
└─────────────────────────────────────┘
               ↓
┌─────────────────────────────────────┐
│       Service层（业务逻辑层）         │
│   - 业务逻辑处理                      │
│   - 事务管理                          │
│   - 调用Mapper层                      │
│   - 调用外部服务（MinIO等）           │
└─────────────────────────────────────┘
               ↓
┌─────────────────────────────────────┐
│       Mapper层（数据访问层）          │
│   - 数据库操作                        │
│   - SQL映射                           │
│   - 数据持久化                        │
└─────────────────────────────────────┘
               ↓
┌─────────────────────────────────────┐
│          MySQL数据库                  │
└─────────────────────────────────────┘
```

#### 1.3.2 核心模块

##### 1.3.2.1 认证模块
- **功能**：用户登录、Token生成、权限验证
- **技术**：Spring Security + JWT
- **流程**：
  1. 用户提交用户名和密码
  2. 验证用户名和密码
  3. 生成JWT Token（有效期24小时）
  4. 返回Token给前端
  5. 前端每次请求携带Token
  6. 后端验证Token并获取用户信息

##### 1.3.2.2 租户管理模块
- **功能**：企业租户的增删改查、配额管理
- **核心类**：
  - TenantController：租户管理接口
  - TenantService：租户业务逻辑
  - TenantMapper：租户数据访问

##### 1.3.2.3 用户管理模块
- **功能**：用户的增删改查、角色分配、状态管理
- **核心类**：
  - UserController：用户管理接口
  - UserService：用户业务逻辑
  - UserMapper：用户数据访问

##### 1.3.2.4 审查任务模块
- **功能**：任务创建、查询、状态管理
- **核心类**：
  - TaskController：任务管理接口
  - TaskService：任务业务逻辑
  - TaskMapper：任务数据访问

##### 1.3.2.5 版本管理模块
- **功能**：版本创建、查询、审查
- **核心类**：
  - VersionController：版本管理接口
  - VersionService：版本业务逻辑
  - VersionMapper：版本数据访问

##### 1.3.2.6 文件管理模块
- **功能**：文件上传、下载、预览、存储
- **技术**：MinIO对象存储
- **核心类**：
  - FileController：文件管理接口
  - FileService：文件业务逻辑（与MinIO交互）
  - FileMapper：文件元数据访问

#### 1.3.3 数据隔离

##### 1.3.3.1 租户隔离
- 所有业务数据表都包含 `tenant_id` 字段
- 通过MyBatis拦截器自动添加租户过滤条件
- 确保租户间数据完全隔离

##### 1.3.3.2 用户隔离
- 普通用户只能查看自己创建的任务
- 审查员只能查看分配给自己的任务
- 企业管理员只能查看本企业的数据
- 平台超管可以查看所有数据

#### 1.3.4 安全机制

##### 1.3.4.1 认证
- 使用Spring Security + JWT
- Token有效期24小时
- 登录失败5次锁定30分钟

##### 1.3.4.2 授权
- 基于角色的访问控制（RBAC）
- 使用@PreAuthorize注解进行权限控制

##### 1.3.4.3 数据安全
- 密码使用BCrypt加密
- SQL注入防护：使用MyBatis参数化查询
- XSS防护：前端输入验证和输出转义

### 1.4 技术选型说明

#### 1.4.1 后端技术选型

| 技术 | 版本 | 选型理由 |
|------|------|----------|
| Java | 8+ | 稳定成熟，生态完善，企业级应用首选 |
| Spring Boot | 2.7.18 | 简化配置，开箱即用，快速开发 |
| Spring MVC | - | RESTful API开发，注解式开发简洁高效 |
| Spring Security | - | 安全框架，提供认证授权功能 |
| MyBatis-Plus | 3.5.5 | 增强MyBatis，简化CRUD操作，提供分页等功能 |
| MySQL | 8.0 | 成熟稳定，支持事务，适合企业应用 |
| HikariCP | - | Spring Boot 默认数据库连接池，高性能 |
| Redis | 7.0 | 缓存中间件，用于登录失败锁定、用户信息缓存 |
| RabbitMQ | 3.12 | 消息队列，用于文件处理、文件复制等异步任务 |
| MinIO | Latest | 开源对象存储，兼容S3协议，适合文件存储 |
| JWT | 0.11.5 | 无状态认证，适合前后端分离 |
| BCrypt | - | 密码加密，安全性高 |
| Knife4j | 4.1.0 | Swagger 增强版，提供美观的 API 文档界面 |
| Lombok | - | 简化Java代码，减少样板代码 |
| Hutool | 5.8.25 | Java工具类库，提供常用工具方法 |
| SLF4J + Logback | - | 日志框架，灵活配置 |

#### 1.4.2 前端技术选型

| 技术 | 版本 | 选型理由 |
|------|------|----------|
| Vue | 3.x | 渐进式框架，易学易用，生态成熟 |
| Element Plus | Latest | Vue 3 PC端UI组件库，组件丰富，文档完善 |
| Vue Router | 4.x | 官方路由库，支持路由守卫 |
| Pinia | Latest | 官方状态管理库，比Vuex更简洁 |
| Axios | Latest | HTTP客户端，支持拦截器，易于封装 |
| PDF.js | 3.11.174 | PDF预览，功能强大，兼容性好 |
| Vite | Latest | 构建工具，开发速度快，HMR体验好 |

**设备支持说明**：
- **主要目标**：PC端（桌面浏览器）
- **次要支持**：移动端可访问，但未做特殊优化
- **技术选型**：Element Plus 主要面向PC端设计，提供丰富的桌面交互体验

#### 1.4.3 部署环境选型

| 技术 | 版本 | 选型理由 |
|------|------|----------|
| Docker | Latest | 容器化部署，环境一致性好 |
| Docker Compose | Latest | 多容器编排，简化部署流程 |
| Nginx | Latest | 反向代理，负载均衡，静态资源服务 |
| Linux | CentOS 7+/Ubuntu 18.04+ | 稳定可靠，适合生产环境 |

## 2. 数据库设计

### 2.1 数据库概述

- 数据库：MySQL 8.0+
- 字符集：utf8mb4
- 排序规则：utf8mb4_unicode_ci
- 存储引擎：InnoDB
- 命名规范：小写字母 + 下划线

### 2.2 表设计

#### 2.2.1 租户表（tenant）

| 字段名 | 类型 | 长度 | 允许空 | 默认值 | 说明 |
|--------|------|------|--------|--------|------|
| id | BIGINT | - | 否 | 自增 | 主键 |
| tenant_name | VARCHAR | 100 | 否 | - | 企业名称，全局唯一 |
| contact_name | VARCHAR | 50 | 否 | - | 联系人姓名 |
| contact_phone | VARCHAR | 20 | 否 | - | 联系电话 |
| storage_quota | BIGINT | - | 否 | 107374182400 | 存储配额（字节），默认100GB |
| storage_used | BIGINT | - | 否 | 0 | 已用存储（字节） |
| user_quota | INT | - | 否 | 50 | 用户数量配额 |
| user_count | INT | - | 否 | 0 | 已创建用户数 |
| status | TINYINT | - | 否 | 1 | 状态：1-正常，0-停用 |
| create_time | DATETIME | - | 否 | CURRENT_TIMESTAMP | 创建时间 |
| update_time | DATETIME | - | 否 | CURRENT_TIMESTAMP ON UPDATE | 更新时间 |
| deleted | TINYINT | - | 否 | 0 | 逻辑删除：0-未删除，1-已删除 |

**索引：**
- 主键索引：id
- 唯一索引：tenant_name
- 普通索引：status

#### 2.2.2 用户表（user）

| 字段名 | 类型 | 长度 | 允许空 | 默认值 | 说明 |
|--------|------|------|--------|--------|------|
| id | BIGINT | - | 否 | 自增 | 主键 |
| tenant_id | BIGINT | - | 是 | NULL | 租户ID，平台超管为NULL |
| username | VARCHAR | 50 | 否 | - | 用户名，企业内唯一 |
| password | VARCHAR | 100 | 否 | - | 密码（BCrypt加密） |
| real_name | VARCHAR | 50 | 否 | - | 真实姓名 |
| phone | VARCHAR | 20 | 是 | NULL | 手机号，企业内唯一 |
| role_platform_admin | TINYINT | - | 否 | 0 | 平台超管角色：1-是，0-否 |
| role_tenant_admin | TINYINT | - | 否 | 0 | 企业管理员角色：1-是，0-否 |
| role_reviewer | TINYINT | - | 否 | 0 | 审查员角色：1-是，0-否 |
| role_user | TINYINT | - | 否 | 0 | 普通用户角色：1-是，0-否 |
| status | TINYINT | - | 否 | 1 | 状态：1-正常，0-停用 |
| last_login_time | DATETIME | - | 是 | NULL | 最后登录时间 |
| create_time | DATETIME | - | 否 | CURRENT_TIMESTAMP | 创建时间 |
| update_time | DATETIME | - | 否 | CURRENT_TIMESTAMP ON UPDATE | 更新时间 |
| deleted | TINYINT | - | 否 | 0 | 逻辑删除：0-未删除，1-已删除 |

**索引：**
- 主键索引：id
- 唯一索引：tenant_id + username
- 唯一索引：tenant_id + phone
- 普通索引：tenant_id
- 普通索引：status

**角色说明：**
- 平台超管：tenant_id为NULL，role_platform_admin=1
- 企业管理员：role_tenant_admin=1，不能与其他角色并存
- 审查员和普通用户：可以同时拥有（role_reviewer=1 AND role_user=1）

#### 2.2.3 审查任务表（review_task）

| 字段名 | 类型 | 长度 | 允许空 | 默认值 | 说明 |
|--------|------|------|--------|--------|------|
| id | BIGINT | - | 否 | 自增 | 主键 |
| tenant_id | BIGINT | - | 否 | - | 租户ID |
| task_name | VARCHAR | 200 | 否 | - | 任务名称，企业内唯一 |
| creator_id | BIGINT | - | 否 | - | 创建人ID |
| reviewer_id | BIGINT | - | 否 | - | 审查员ID |
| current_version | INT | - | 否 | 1 | 当前版本号 |
| current_status | VARCHAR | 20 | 否 | 'REVIEWING' | 当前状态：REVIEWING-审查中，APPROVED-已通过，REJECTED-已打回 |
| create_time | DATETIME | - | 否 | CURRENT_TIMESTAMP | 创建时间 |
| update_time | DATETIME | - | 否 | CURRENT_TIMESTAMP ON UPDATE | 更新时间 |
| deleted | TINYINT | - | 否 | 0 | 逻辑删除：0-未删除，1-已删除 |

**索引：**
- 主键索引：id
- 唯一索引：tenant_id + task_name
- 普通索引：tenant_id
- 普通索引：creator_id
- 普通索引：reviewer_id
- 普通索引：current_status

#### 2.2.4 审查版本表（review_version）

| 字段名 | 类型 | 长度 | 允许空 | 默认值 | 说明 |
|--------|------|------|--------|--------|------|
| id | BIGINT | - | 否 | 自增 | 主键 |
| tenant_id | BIGINT | - | 否 | - | 租户ID |
| task_id | BIGINT | - | 否 | - | 任务ID |
| version_number | INT | - | 否 | - | 版本号（1, 2, 3...） |
| submit_desc | TEXT | - | 是 | NULL | 提交说明 |
| submit_time | DATETIME | - | 否 | CURRENT_TIMESTAMP | 提交时间 |
| status | VARCHAR | 20 | 否 | 'REVIEWING' | 审查状态：REVIEWING-审查中，APPROVED-已通过，REJECTED-已打回 |
| review_result | VARCHAR | 20 | 是 | NULL | 审查结果：APPROVED-通过，REJECTED-打回 |
| review_comment | TEXT | 是 | NULL | - | 审查意见 |
| reviewer_id | BIGINT | - | 是 | NULL | 审查人ID |
| review_time | DATETIME | - | 是 | NULL | 审查时间 |
| files_ready | TINYINT | - | 否 | 0 | 文件是否就绪：0-复制中，1-已就绪（用于异步复制） |
| file_count | INT | - | 否 | 0 | 文件数量 |
| create_time | DATETIME | - | 否 | CURRENT_TIMESTAMP | 创建时间 |
| update_time | DATETIME | - | 否 | CURRENT_TIMESTAMP ON UPDATE | 更新时间 |
| deleted | TINYINT | - | 否 | 0 | 逻辑删除：0-未删除，1-已删除 |

**索引：**
- 主键索引：id
- 唯一索引：task_id + version_number
- 普通索引：tenant_id
- 普通索引：task_id
- 普通索引：status

**字段说明：**
- files_ready：用于标识版本文件是否已通过RabbitMQ异步复制完成，0表示正在复制，1表示已就绪
- file_count：该版本包含的文件数量，方便统计和展示

#### 2.2.5 文件表（review_file）

| 字段名 | 类型 | 长度 | 允许空 | 默认值 | 说明 |
|--------|------|------|--------|--------|------|
| id | BIGINT | - | 否 | 自增 | 主键 |
| tenant_id | BIGINT | - | 否 | - | 租户ID |
| version_id | BIGINT | - | 否 | - | 版本ID |
| file_name | VARCHAR | 255 | 否 | - | 原始文件名（如：财务报表.pdf） |
| file_size | BIGINT | - | 否 | - | 文件大小（字节） |
| file_type | VARCHAR | 50 | 否 | - | 文件类型（如：pdf） |
| file_md5 | VARCHAR | 32 | 否 | - | 文件MD5值，用于去重 |
| minio_object_name | VARCHAR | 500 | 否 | - | MinIO对象名（格式：tenant_id/md5） |
| upload_time | DATETIME | - | 否 | CURRENT_TIMESTAMP | 上传时间 |
| deleted | TINYINT | - | 否 | 0 | 逻辑删除：0-未删除，1-已删除 |

**索引：**
- 主键索引：id
- 普通索引：tenant_id
- 普通索引：version_id
- 普通索引：file_md5
- 联合索引：tenant_id + file_md5 + deleted（用于去重查询）
- 唯一索引：version_id + file_name（同一版本下，文件名唯一）

**字段说明：**
- file_name：用户上传的原始文件名，同一版本下必须唯一，避免混淆
- file_type：文件扩展名，当前仅支持pdf，后续可扩展
- minio_object_name：MinIO中的实际存储路径，格式为tenant_id/md5，相同MD5的文件只存储一份

### 2.3 数据库关系

```
tenant (租户表)
    ↓ 1:N
user (用户表)

tenant (租户表)
    ↓ 1:N
review_task (任务表)
    ↓ 1:N
review_version (版本表)
    ↓ 1:N
review_file (文件表)

user (用户表 - creator_id)
    ↓ 1:N
review_task (任务表)

user (用户表 - reviewer_id)
    ↓ 1:N
review_task (任务表)
```

### 2.4 数据隔离说明

1. **租户隔离**：所有业务表都包含 `tenant_id` 字段，查询时自动添加租户过滤条件
2. **逻辑删除**：所有表都使用 `deleted` 字段实现逻辑删除，物理数据不真正删除
3. **版本独立性**：每个版本的文件独立存储，删除某个版本不影响其他版本

## 3. 核心功能与技术实现

### 3.1 用户认证与授权

#### 3.1.1 认证流程

**登录流程：**

1. **用户提交登录请求**
   - 前端发送POST请求到 `/api/auth/login`
   - 请求体：`{ "username": "xxx", "password": "xxx" }`

2. **后端验证**
   - 根据 `username` 查询用户
   - 使用 `BCryptPasswordEncoder.matches()` 验证密码
   - 验证失败次数检查（失败5次锁定30分钟）
   - 验证用户状态（status=1）和租户状态

3. **生成JWT Token**
   - 使用 `JwtUtil.generateToken()` 生成Token
   - Token包含信息：userId, username, tenantId, roles
   - Token有效期：24小时

4. **返回响应**
   - 成功：返回Token和用户基本信息
   - 失败：返回错误信息

**Token验证流程：**

1. 前端每次请求携带Token（Header: `Authorization: Bearer {token}`）
2. `JwtFilter` 拦截请求，提取Token
3. `JwtUtil.validateToken()` 验证Token有效性
4. 从Token中解析用户信息，存入 `SecurityContextHolder`
5. 继续执行请求

#### 3.1.2 授权控制

**基于角色的权限控制（RBAC）：**

| 角色 | 权限范围 |
|------|---------|
| 平台超管 | 管理所有租户、查看平台统计、管理企业管理员 |
| 企业管理员 | 管理本企业用户（增删改查） |
| 审查员 | 查看分配给自己的审查任务、执行审查操作 |
| 普通用户 | 创建审查任务、提交新版本、查看自己的任务 |

**实现方式：**

```java
// Controller层使用@PreAuthorize注解
@PreAuthorize("hasRole('PLATFORM_ADMIN')")
public Result createTenant() { }

@PreAuthorize("hasRole('TENANT_ADMIN')")
public Result createUser() { }

@PreAuthorize("hasRole('REVIEWER')")
public Result reviewVersion() { }

@PreAuthorize("hasRole('USER')")
public Result createTask() { }
```

**数据权限过滤：**

- 通过MyBatis拦截器自动添加 `tenant_id` 过滤条件
- Service层根据角色过滤数据：
  - 普通用户：只能查询 `creator_id = 当前用户ID` 的任务
  - 审查员：只能查询 `reviewer_id = 当前用户ID` 的任务
  - 企业管理员：可以查询本企业所有数据
  - 平台超管：可以查询所有数据

#### 3.1.3 安全措施

1. **密码加密**
   - 使用BCrypt算法加密密码
   - 每次加密生成不同的盐值
   - 密码强度要求：最少6位

2. **登录失败锁定**
   - 使用Redis存储登录失败次数
   - Key: `login:fail:{username}`
   - 失败5次锁定30分钟

3. **SQL注入防护**
   - 使用MyBatis参数化查询
   - 禁止拼接SQL字符串

4. **XSS防护**
   - 前端输入验证
   - 后端输出转义
   - 使用Element Plus组件自动转义

#### 3.1.4 前端路由权限控制

**路由配置（router/index.js）：**

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
    meta: { requiresAuth: false }
  },
  // 平台超管路由
  {
    path: '/platform',
    component: () => import('@/layout/PlatformLayout.vue'),
    meta: { requiresAuth: true, roles: ['PLATFORM_ADMIN'] },
    children: [
      {
        path: 'tenants',
        name: 'TenantManagement',
        component: () => import('@/views/platform/TenantManagement.vue')
      },
      {
        path: 'statistics',
        name: 'PlatformStatistics',
        component: () => import('@/views/platform/Statistics.vue')
      }
    ]
  },
  // 企业管理员路由
  {
    path: '/admin',
    component: () => import('@/layout/AdminLayout.vue'),
    meta: { requiresAuth: true, roles: ['TENANT_ADMIN'] },
    children: [
      {
        path: 'users',
        name: 'UserManagement',
        component: () => import('@/views/admin/UserManagement.vue')
      }
    ]
  },
  // 审查员路由
  {
    path: '/reviewer',
    component: () => import('@/layout/ReviewerLayout.vue'),
    meta: { requiresAuth: true, roles: ['REVIEWER'] },
    children: [
      {
        path: 'tasks',
        name: 'ReviewTasks',
        component: () => import('@/views/reviewer/TaskList.vue')
      },
      {
        path: 'review/:versionId',
        name: 'ReviewDetail',
        component: () => import('@/views/reviewer/ReviewDetail.vue')
      }
    ]
  },
  // 普通用户路由
  {
    path: '/user',
    component: () => import('@/layout/UserLayout.vue'),
    meta: { requiresAuth: true, roles: ['USER'] },
    children: [
      {
        path: 'my-tasks',
        name: 'MyTasks',
        component: () => import('@/views/user/MyTasks.vue')
      },
      {
        path: 'create-task',
        name: 'CreateTask',
        component: () => import('@/views/user/CreateTask.vue')
      }
    ]
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 路由守卫
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()

  // 不需要登录的页面
  if (!to.meta.requiresAuth) {
    next()
    return
  }

  // 检查是否已登录
  if (!authStore.isLoggedIn) {
    next('/login')
    return
  }

  // 检查角色权限
  const requiredRoles = to.meta.roles
  const currentRole = authStore.currentRole

  if (requiredRoles && !requiredRoles.includes(currentRole)) {
    // 无权限，跳转到当前角色的默认页面
    next(authStore.getDefaultRoute())
    return
  }

  next()
})

export default router
```

#### 3.1.5 角色动态切换实现

**Pinia状态管理（stores/auth.js）：**

```javascript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import router from '@/router'

export const useAuthStore = defineStore('auth', () => {
  // 状态
  const token = ref(localStorage.getItem('token') || '')
  const userInfo = ref(JSON.parse(localStorage.getItem('userInfo') || '{}'))
  const availableRoles = ref(JSON.parse(localStorage.getItem('roles') || '[]'))
  const currentRole = ref(localStorage.getItem('currentRole') || '')

  // 计算属性
  const isLoggedIn = computed(() => !!token.value)

  const isDualRole = computed(() => {
    // 检查是否同时拥有审查员和普通用户角色
    const roles = availableRoles.value
    return roles.includes('REVIEWER') && roles.includes('USER')
  })

  // 登录
  function login(loginData) {
    token.value = loginData.token
    userInfo.value = loginData.userInfo
    availableRoles.value = loginData.roles

    // 设置默认角色
    if (loginData.roles.length === 1) {
      currentRole.value = loginData.roles[0]
    } else if (loginData.roles.includes('REVIEWER')) {
      currentRole.value = 'REVIEWER'
    } else {
      currentRole.value = loginData.roles[0]
    }

    // 保存到localStorage
    localStorage.setItem('token', token.value)
    localStorage.setItem('userInfo', JSON.stringify(userInfo.value))
    localStorage.setItem('roles', JSON.stringify(availableRoles.value))
    localStorage.setItem('currentRole', currentRole.value)

    // 跳转到默认页面
    router.push(getDefaultRoute())
  }

  // 退出登录
  function logout() {
    token.value = ''
    userInfo.value = {}
    availableRoles.value = []
    currentRole.value = ''

    localStorage.removeItem('token')
    localStorage.removeItem('userInfo')
    localStorage.removeItem('roles')
    localStorage.removeItem('currentRole')

    router.push('/login')
  }

  // 切换角色
  function switchRole(role) {
    if (!availableRoles.value.includes(role)) {
      console.error('无权切换到该角色')
      return
    }

    currentRole.value = role
    localStorage.setItem('currentRole', role)

    // 跳转到新角色的默认页面
    router.push(getDefaultRoute())
  }

  // 获取默认路由
  function getDefaultRoute() {
    const roleRouteMap = {
      'PLATFORM_ADMIN': '/platform/tenants',
      'TENANT_ADMIN': '/admin/users',
      'REVIEWER': '/reviewer/tasks',
      'USER': '/user/my-tasks'
    }
    return roleRouteMap[currentRole.value] || '/login'
  }

  return {
    token,
    userInfo,
    availableRoles,
    currentRole,
    isLoggedIn,
    isDualRole,
    login,
    logout,
    switchRole,
    getDefaultRoute
  }
})
```

**顶部导航组件（components/layout/TopBar.vue）：**

```vue
<template>
  <div class="top-bar">
    <div class="left">
      <h2>文件审查系统</h2>
    </div>
    <div class="right">
      <!-- 角色切换下拉框（仅双角色用户显示） -->
      <el-dropdown v-if="authStore.isDualRole" @command="handleRoleSwitch">
        <span class="role-switch">
          {{ currentRoleLabel }}
          <el-icon><ArrowDown /></el-icon>
        </span>
        <template #dropdown>
          <el-dropdown-menu>
            <el-dropdown-item command="REVIEWER">
              切换到：审查员
            </el-dropdown-item>
            <el-dropdown-item command="USER">
              切换到：普通用户
            </el-dropdown-item>
          </el-dropdown-menu>
        </template>
      </el-dropdown>

      <!-- 用户信息下拉框 -->
      <el-dropdown @command="handleUserAction">
        <span class="user-info">
          <el-avatar :size="32">{{ userInfo.realName?.charAt(0) }}</el-avatar>
          <span class="username">{{ userInfo.realName }}</span>
          <el-icon><ArrowDown /></el-icon>
        </span>
        <template #dropdown>
          <el-dropdown-menu>
            <el-dropdown-item command="changePassword">
              修改密码
            </el-dropdown-item>
            <el-dropdown-item command="logout" divided>
              退出登录
            </el-dropdown-item>
          </el-dropdown-menu>
        </template>
      </el-dropdown>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useAuthStore } from '@/stores/auth'
import { ArrowDown } from '@element-plus/icons-vue'

const authStore = useAuthStore()
const userInfo = computed(() => authStore.userInfo)
const currentRole = computed(() => authStore.currentRole)

const currentRoleLabel = computed(() => {
  const roleLabels = {
    'REVIEWER': '当前角色：审查员',
    'USER': '当前角色：普通用户'
  }
  return roleLabels[currentRole.value] || ''
})

// 切换角色
function handleRoleSwitch(role) {
  authStore.switchRole(role)
}

// 用户操作
function handleUserAction(command) {
  if (command === 'logout') {
    authStore.logout()
  } else if (command === 'changePassword') {
    // 打开修改密码对话框
  }
}
</script>

<style scoped>
.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 60px;
  padding: 0 20px;
  background: #fff;
  border-bottom: 1px solid #e4e7ed;
}

.right {
  display: flex;
  align-items: center;
  gap: 20px;
}

.role-switch,
.user-info {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}

.role-switch {
  color: #409eff;
  font-weight: 500;
}
</style>
```

**关键特性：**

1. **无刷新切换**：使用Pinia状态管理，切换角色时不刷新页面
2. **路由守卫**：自动根据当前角色过滤可访问的路由
3. **持久化存储**：角色状态保存在localStorage，刷新页面保持当前角色
4. **默认路由**：切换角色后自动跳转到该角色的默认页面
5. **权限隔离**：不同角色看到不同的菜单和页面

### 3.2 租户管理实现

#### 3.2.1 租户创建

**业务逻辑：**

1. **参数验证**
   - 企业名称不能为空，全局唯一
   - 联系人姓名、电话不能为空
   - 存储配额默认100GB（107374182400字节）
   - 用户配额默认50个

2. **数据库操作**
   - 插入tenant表
   - 初始化 `storage_used=0`, `user_count=0`, `status=1`

3. **创建默认管理员**
   - 自动创建企业管理员账号
   - 用户名：与企业名称相同
   - 初始密码：系统生成或用户指定

**核心代码逻辑：**

```java
@Transactional
public void createTenant(TenantCreateRequest request) {
    // 1. 检查企业名称是否已存在
    if (tenantMapper.existsByName(request.getTenantName())) {
        throw new BusinessException("企业名称已存在");
    }

    // 2. 创建租户
    Tenant tenant = new Tenant();
    tenant.setTenantName(request.getTenantName());
    tenant.setStorageQuota(request.getStorageQuota() * 1024 * 1024 * 1024);
    tenant.setUserQuota(request.getUserQuota());
    tenantMapper.insert(tenant);

    // 3. 创建企业管理员（可选）
}
```

#### 3.2.2 配额管理

**存储配额控制：**

1. **上传文件时检查**
   - 计算文件大小
   - 查询租户已用存储：`storage_used`
   - 查询租户存储配额：`storage_quota`
   - 判断：`storage_used + file_size <= storage_quota`

2. **更新已用存储**
   - 文件上传成功后：`storage_used += file_size`
   - 文件删除后：`storage_used -= file_size`

**用户配额控制：**

1. **创建用户时检查**
   - 查询租户已创建用户数：`user_count`
   - 查询租户用户配额：`user_quota`
   - 判断：`user_count < user_quota`

2. **更新用户数量**
   - 创建用户成功后：`user_count += 1`
   - 删除用户后：`user_count -= 1`

#### 3.2.3 租户停用/启用

**停用租户：**

- 将 `tenant.status` 设置为 0
- 该租户下所有用户无法登录
- 登录时验证：`user.status=1 AND tenant.status=1`

**启用租户：**

- 将 `tenant.status` 设置为 1
- 该租户下状态正常的用户恢复登录

### 3.3 文件上传与存储

#### 3.3.1 MinIO配置

**配置参数：**

```yaml
minio:
  endpoint: http://minio:9000
  accessKey: minioadmin
  secretKey: minioadmin
  bucketName: review-files
```

**初始化：**

```java
@Configuration
public class MinioConfig {
    @Bean
    public MinioClient minioClient() {
        return MinioClient.builder()
            .endpoint(endpoint)
            .credentials(accessKey, secretKey)
            .build();
    }
}
```

#### 3.3.2 文件上传流程

**完整流程：**

1. **前端计算MD5**
   - 使用Web Worker后台计算文件MD5
   - 显示"计算文件指纹"进度条
   - 2MB分片计算，避免阻塞UI

2. **检查文件是否存在（秒传）**
   - 前端携带MD5请求：`POST /api/file/check-exists`
   - 后端查询 `review_file` 表中是否存在该MD5
   - 如存在：返回 `{exists: true, minioObjectName: "xxx"}`
   - 如不存在：返回 `{exists: false}`

3. **秒传或上传文件**
   - **秒传**：如文件已存在，直接创建文件记录，关联到当前版本
   - **上传**：如文件不存在，执行完整上传流程

4. **上传到MinIO（非秒传情况）**
   - 使用Element Plus的 `el-upload` 组件
   - 文件类型限制：`.pdf`
   - 文件大小限制：200MB
   - Controller接收 `MultipartFile` 和 `md5` 参数
   - 验证文件类型：`file.getContentType() == "application/pdf"`
   - 验证文件大小：`file.getSize() <= 200 * 1024 * 1024`

5. **检查存储配额**
   - 查询租户存储配额和已用存储
   - 判断是否超出配额

6. **生成MinIO存储路径**
   - **对象名格式**：`{tenant_id}/{md5}`
   - 示例：`1001/a3b2c1d4e5f6...`
   - 相同MD5的文件只存储一份，实现去重

7. **上传到MinIO**
   - 使用 `minioClient.putObject()` 上传
   - 设置Content-Type为 `application/pdf`

8. **保存文件元数据**
   - 插入 `review_file` 表
   - 记录：`file_name`（原始文件名）、`minio_object_name`（MinIO对象名）、`file_md5`、`file_size`、`file_type`

9. **更新租户存储使用量**
   - 仅在新上传文件时更新（秒传不更新）
   - `UPDATE tenant SET storage_used = storage_used + file_size`

**核心代码：**

```java
// 1. 检查文件是否存在接口
@PostMapping("/check-exists")
public FileExistsResponse checkFileExists(@RequestBody FileCheckRequest request) {
    Long tenantId = getCurrentTenantId();

    // 查询是否存在相同MD5的文件
    ReviewFile existingFile = fileMapper.selectOne(
        new QueryWrapper<ReviewFile>()
            .eq("tenant_id", tenantId)
            .eq("file_md5", request.getMd5())
            .last("LIMIT 1")
    );

    if (existingFile != null) {
        return new FileExistsResponse(true, existingFile.getMinioObjectName());
    }
    return new FileExistsResponse(false, null);
}

// 2. 文件上传接口
@Transactional
public FileUploadResponse uploadFile(MultipartFile file, String md5,
                                     String fileName, Long versionId) {
    // 1. 验证文件
    if (!file.getContentType().equals("application/pdf")) {
        throw new BusinessException("仅支持PDF文件");
    }
    if (file.getSize() > 200 * 1024 * 1024) {
        throw new BusinessException("文件大小不能超过200MB");
    }

    Long tenantId = getCurrentTenantId();

    // 2. 检查版本下文件名是否重复
    Long count = fileMapper.selectCount(
        new QueryWrapper<ReviewFile>()
            .eq("version_id", versionId)
            .eq("file_name", fileName)
    );
    if (count > 0) {
        throw new BusinessException("该版本下已存在同名文件");
    }

    // 3. 检查MD5是否已存在（秒传逻辑）
    ReviewFile existingFile = fileMapper.selectOne(
        new QueryWrapper<ReviewFile>()
            .eq("tenant_id", tenantId)
            .eq("file_md5", md5)
            .last("LIMIT 1")
    );

    String minioObjectName;
    boolean isNewUpload = (existingFile == null);

    if (isNewUpload) {
        // 4. 检查存储配额
        Tenant tenant = tenantMapper.selectById(tenantId);
        if (tenant.getStorageUsed() + file.getSize() > tenant.getStorageQuota()) {
            throw new BusinessException("存储空间不足");
        }

        // 5. 生成MinIO对象名
        minioObjectName = String.format("%d/%s", tenantId, md5);

        // 6. 上传到MinIO
        minioClient.putObject(
            PutObjectArgs.builder()
                .bucket(bucketName)
                .object(minioObjectName)
                .stream(file.getInputStream(), file.getSize(), -1)
                .contentType("application/pdf")
                .build()
        );

        // 7. 更新存储使用量（仅新上传文件时）
        tenantMapper.increaseStorageUsed(tenantId, file.getSize());
    } else {
        // 秒传：复用已存在文件的MinIO对象名
        minioObjectName = existingFile.getMinioObjectName();
    }

    // 8. 保存元数据（无论秒传还是新上传，都要创建记录）
    ReviewFile reviewFile = new ReviewFile();
    reviewFile.setTenantId(tenantId);
    reviewFile.setVersionId(versionId);
    reviewFile.setFileName(fileName);
    reviewFile.setMinioObjectName(minioObjectName);
    reviewFile.setFileMd5(md5);
    reviewFile.setFileSize(file.getSize());
    reviewFile.setFileType("application/pdf");
    fileMapper.insert(reviewFile);

    return new FileUploadResponse(reviewFile.getId(), minioObjectName, isNewUpload);
}
```

#### 3.3.3 文件下载与预览

**文件下载：**

1. 前端请求：`GET /api/file/download/{fileId}`
2. 后端验证权限：检查文件所属任务的访问权限
3. 查询文件元数据，获取 `minio_object_name` 和 `file_name`
4. 从MinIO获取文件流：`minioClient.getObject(bucketName, minioObjectName)`
5. 设置响应头：`Content-Disposition: attachment; filename="{file_name}"`（使用原始文件名）
6. 返回文件流

**文件预览：**

1. 前端请求预览URL：`GET /api/file/preview/{fileId}`
2. 后端验证权限
3. 查询文件元数据，获取 `minio_object_name`
4. 生成预签名URL：`minioClient.getPresignedObjectUrl(bucketName, minioObjectName)`
5. URL有效期：7天
6. 前端使用PDF.js加载预签名URL显示PDF

#### 3.3.4 文件复制机制

**提交新版本时复制文件（异步处理）：**

由于使用MD5去重机制，相同内容的文件在MinIO中只存储一份，因此文件复制不需要在MinIO中复制物理文件，只需要在数据库中创建新的文件记录，关联到新版本即可。

为避免阻塞用户操作，文件复制使用RabbitMQ异步处理：

**同步流程（提交新版本时）：**

1. 创建新版本记录，设置 `files_ready = 0`（文件未就绪）
2. 发送消息到RabbitMQ队列：`{taskId, oldVersionId, newVersionId}`
3. 立即返回给前端，告知"正在复制文件，请稍候..."

**异步流程（RabbitMQ消费者）：**

1. 消费者接收消息
2. 查询上一版本的所有文件
3. 遍历每个文件，复制元数据记录到新版本
4. 更新版本表：`files_ready = 1`

**前端轮询机制：**

1. 提交新版本后，前端每2秒轮询一次：`GET /api/version/{versionId}/status`
2. 检查 `files_ready` 字段是否为1
3. 最多轮询30次（60秒），超时则提示用户刷新页面
4. 文件就绪后，跳转到文件上传页面

**核心代码：**

```java
// 1. 提交新版本时发送MQ消息
@Transactional
public Long submitNewVersion(Long taskId, VersionSubmitRequest request) {
    // ... 创建新版本逻辑 ...
    Version newVersion = new Version();
    newVersion.setFilesReady(0); // 文件未就绪
    // ... 其他字段设置 ...
    versionMapper.insert(newVersion);

    // 发送异步复制消息
    rabbitTemplate.convertAndSend(
        "file.copy.exchange",
        "file.copy.routing.key",
        new FileCopyMessage(taskId, oldVersionId, newVersion.getId())
    );

    return newVersion.getId();
}

// 2. RabbitMQ消费者
@RabbitListener(queues = "file.copy.queue")
public void copyFilesToNewVersion(FileCopyMessage message) {
    Long oldVersionId = message.getOldVersionId();
    Long newVersionId = message.getNewVersionId();

    // 查询上一版本的文件
    List<ReviewFile> oldFiles = fileMapper.selectByVersionId(oldVersionId);

    // 复制文件元数据（不复制MinIO文件，复用minio_object_name）
    for (ReviewFile oldFile : oldFiles) {
        ReviewFile newFile = new ReviewFile();
        BeanUtils.copyProperties(oldFile, newFile);
        newFile.setId(null);
        newFile.setVersionId(newVersionId);
        // minio_object_name保持不变，复用同一个MinIO对象
        fileMapper.insert(newFile);
    }

    // 更新版本状态为文件已就绪
    Version version = versionMapper.selectById(newVersionId);
    version.setFilesReady(1);
    version.setFileCount(oldFiles.size());
    versionMapper.updateById(version);
}

// 3. 查询版本状态接口
@GetMapping("/version/{versionId}/status")
public VersionStatusResponse getVersionStatus(@PathVariable Long versionId) {
    Version version = versionMapper.selectById(versionId);
    return new VersionStatusResponse(
        version.getFilesReady() == 1,
        version.getFileCount()
    );
}
```

### 3.4 审查流程实现

#### 3.4.1 创建审查任务

**业务流程：**

1. **验证参数**
   - 任务名称不能为空，企业内唯一
   - 审查员ID不能为空，必须是本企业的审查员
   - 至少上传1个PDF文件

2. **创建任务**
   - 插入 `review_task` 表
   - 字段：`task_name`, `creator_id`, `reviewer_id`, `current_version=1`, `current_status='REVIEWING'`

3. **创建版本v1**
   - 插入 `review_version` 表
   - 字段：`task_id`, `version_number=1`, `submit_desc`, `status='REVIEWING'`

4. **上传文件**
   - 调用文件上传接口上传所有文件
   - 文件关联到版本v1

**事务控制：**

整个创建过程使用 `@Transactional` 保证原子性，任何步骤失败都会回滚。

#### 3.4.2 执行审查

**审查流程：**

1. **验证权限**
   - 检查当前用户是否是该任务的审查员
   - 检查版本状态是否为 `REVIEWING`

2. **提交审查结果**
   - 审查结果：`APPROVED` 或 `REJECTED`
   - 审查意见：文本，可选

3. **更新版本表**
   - `status` = 审查结果（APPROVED/REJECTED）
   - `review_result` = 审查结果
   - `review_comment` = 审查意见
   - `reviewer_id` = 当前用户ID
   - `review_time` = 当前时间

4. **更新任务表**
   - `current_status` = 审查结果
   - `update_time` = 当前时间

**核心代码：**

```java
@Transactional
public void reviewVersion(Long versionId, ReviewRequest request) {
    // 1. 查询版本
    Version version = versionMapper.selectById(versionId);
    if (version == null) {
        throw new BusinessException("版本不存在");
    }

    // 2. 验证权限
    Task task = taskMapper.selectById(version.getTaskId());
    if (!task.getReviewerId().equals(getCurrentUserId())) {
        throw new BusinessException("无权审查该任务");
    }

    // 3. 验证状态
    if (!version.getStatus().equals("REVIEWING")) {
        throw new BusinessException("该版本已审查完成");
    }

    // 4. 更新版本
    version.setStatus(request.getReviewResult());
    version.setReviewResult(request.getReviewResult());
    version.setReviewComment(request.getReviewComment());
    version.setReviewerId(getCurrentUserId());
    version.setReviewTime(LocalDateTime.now());
    versionMapper.updateById(version);

    // 5. 更新任务
    task.setCurrentStatus(request.getReviewResult());
    taskMapper.updateById(task);
}
```

#### 3.4.3 提交新版本

**业务流程：**

1. **验证前置条件**
   - 任务当前状态必须是 `REJECTED`
   - 用户必须是任务创建者

2. **计算新版本号**
   - 查询任务的 `current_version`
   - 新版本号 = `current_version + 1`

3. **复制上一版本文件**
   - 调用文件复制接口
   - 将上一版本的所有文件复制到新版本路径

4. **创建新版本**
   - 插入 `review_version` 表
   - 字段：`task_id`, `version_number`, `submit_desc`, `status='REVIEWING'`

5. **允许文件修改**
   - 用户可以删除复制的文件
   - 用户可以上传新文件
   - 用户可以替换文件（删除旧文件+上传新文件）

6. **更新任务状态**
   - `current_version` = 新版本号
   - `current_status` = 'REVIEWING'

**核心代码：**

```java
@Transactional
public Long submitNewVersion(Long taskId, VersionSubmitRequest request) {
    // 1. 查询任务
    Task task = taskMapper.selectById(taskId);
    if (task == null) {
        throw new BusinessException("任务不存在");
    }

    // 2. 验证权限和状态
    if (!task.getCreatorId().equals(getCurrentUserId())) {
        throw new BusinessException("无权提交该任务");
    }
    if (!task.getCurrentStatus().equals("REJECTED")) {
        throw new BusinessException("只有被打回的任务才能提交新版本");
    }

    // 3. 计算新版本号
    int newVersionNumber = task.getCurrentVersion() + 1;

    // 4. 创建新版本
    Version newVersion = new Version();
    newVersion.setTenantId(getCurrentTenantId());
    newVersion.setTaskId(taskId);
    newVersion.setVersionNumber(newVersionNumber);
    newVersion.setSubmitDesc(request.getSubmitDesc());
    newVersion.setStatus("REVIEWING");
    versionMapper.insert(newVersion);

    // 5. 复制文件
    Long oldVersionId = versionMapper.selectByTaskIdAndVersionNumber(
        taskId, task.getCurrentVersion()).getId();
    copyFilesToNewVersion(taskId, oldVersionId, newVersion.getId());

    // 6. 更新任务
    task.setCurrentVersion(newVersionNumber);
    task.setCurrentStatus("REVIEWING");
    taskMapper.updateById(task);

    return newVersion.getId();
}
```

### 3.5 版本控制实现

#### 3.5.1 版本数据模型

**版本与任务的关系：**

- 任务表（review_task）存储当前状态：`current_version`, `current_status`
- 版本表（review_version）存储历史记录：每个版本的详细信息

**版本状态流转：**

```
创建任务 → 版本v1（REVIEWING）
         ↓
    审查员审查
         ↓
    ┌─── APPROVED（结束）
    │
    └─── REJECTED → 提交版本v2（REVIEWING）
                    ↓
               审查员审查
                    ↓
               ┌─── APPROVED（结束）
               │
               └─── REJECTED → 提交版本v3...
```

#### 3.5.2 版本查询

**查询任务的所有版本：**

```sql
SELECT * FROM review_version
WHERE task_id = ?
  AND deleted = 0
ORDER BY version_number DESC
```

**查询特定版本详情：**

```sql
SELECT
    v.*,
    u1.real_name as creator_name,
    u2.real_name as reviewer_name
FROM review_version v
LEFT JOIN review_task t ON v.task_id = t.id
LEFT JOIN user u1 ON t.creator_id = u1.id
LEFT JOIN user u2 ON v.reviewer_id = u2.id
WHERE v.id = ? AND v.deleted = 0
```

#### 3.5.3 版本文件管理

**查询版本的所有文件：**

```sql
SELECT * FROM review_file
WHERE version_id = ?
  AND deleted = 0
ORDER BY upload_time ASC
```

**文件名唯一性检查：**

```sql
SELECT COUNT(*) FROM review_file
WHERE version_id = ?
  AND file_name = ?
  AND deleted = 0
```

**删除版本文件（逻辑删除）：**

1. 更新 `review_file.deleted = 1`
2. 从MinIO删除物理文件
3. 更新租户存储使用量：`storage_used -= file_size`

### 3.6 数据隔离实现

#### 3.6.1 租户隔离拦截器

**MyBatis拦截器实现：**

```java
@Intercepts({
    @Signature(type = Executor.class, method = "query",
               args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class TenantInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 1. 获取当前租户ID
        Long tenantId = TenantContext.getCurrentTenantId();
        if (tenantId == null) {
            // 平台超管，不添加租户过滤
            return invocation.proceed();
        }

        // 2. 解析SQL
        MappedStatement ms = (MappedStatement) invocation.getArgs()[0];
        Object parameter = invocation.getArgs()[1];

        // 3. 添加租户过滤条件
        BoundSql boundSql = ms.getBoundSql(parameter);
        String sql = boundSql.getSql();
        String newSql = addTenantCondition(sql, tenantId);

        // 4. 重新执行
        // ...
    }

    private String addTenantCondition(String sql, Long tenantId) {
        // 在WHERE子句中添加 AND tenant_id = {tenantId}
        // 如果没有WHERE子句，则添加 WHERE tenant_id = {tenantId}
    }
}
```

#### 3.6.2 用户数据隔离

**Service层数据过滤：**

```java
public List<Task> getMyTasks(String status) {
    Long userId = getCurrentUserId();
    String userRole = getCurrentUserRole();

    if ("USER".equals(userRole)) {
        // 普通用户：只能看自己创建的任务
        return taskMapper.selectByCreatorId(userId, status);
    } else if ("REVIEWER".equals(userRole)) {
        // 审查员：只能看分配给自己的任务
        return taskMapper.selectByReviewerId(userId, status);
    } else if ("TENANT_ADMIN".equals(userRole)) {
        // 企业管理员：可以看本企业所有任务
        return taskMapper.selectByTenantId(getCurrentTenantId(), status);
    } else if ("PLATFORM_ADMIN".equals(userRole)) {
        // 平台超管：可以看所有任务
        return taskMapper.selectAll(status);
    }
}
```

### 3.7 异常处理

#### 3.7.1 业务异常定义

```java
public class BusinessException extends RuntimeException {
    private String code;
    private String message;

    public BusinessException(String message) {
        super(message);
        this.code = "BUSINESS_ERROR";
        this.message = message;
    }
}
```

#### 3.7.2 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public Result handleBusinessException(BusinessException e) {
        return Result.error(e.getCode(), e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public Result handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error("SYSTEM_ERROR", "系统异常，请联系管理员");
    }
}
```

### 3.8 异步处理与性能优化

#### 3.8.1 文件上传性能优化

##### 3.8.1.1 性能瓶颈分析

**场景描述：** 100个用户同时上传200MB文件

**网络带宽瓶颈：**
- 总数据量：100 × 200MB = 20GB
- 典型服务器出口带宽：1Gbps~10Gbps
- 1Gbps理论传输速度：125MB/s
- 传输20GB所需时间：20GB ÷ 125MB/s ≈ 160秒
- **结论：** 网络带宽是主要瓶颈，需要通过限流和排队机制避免网络拥塞

**服务器内存瓶颈：**
- 传统全量上传方式：100个请求 × 200MB/请求 = 20GB内存
- 典型服务器内存：16GB~32GB
- **结论：** 全量加载会导致内存溢出，必须采用流式处理

**Tomcat线程池瓶颈：**
- Tomcat默认最大线程数：200
- 100个并发长连接会占用一半线程资源
- 其他API请求响应变慢
- **结论：** 需要异步处理机制释放Tomcat线程

##### 3.8.1.2 流式处理避免内存溢出

**问题：**
- 传统方式：`byte[] fileBytes = file.getBytes()` 会将整个文件加载到内存
- 200MB文件 × 100并发 = 20GB内存，导致OOM

**解决方案：使用流式传输**
```java
@PostMapping("/upload")
public Result uploadFile(@RequestParam("file") MultipartFile file) {
    try (InputStream inputStream = file.getInputStream()) {
        // 直接使用流上传到MinIO，不加载到内存
        minioClient.putObject(
            PutObjectArgs.builder()
                .bucket(bucketName)
                .object(objectName)
                .stream(inputStream, file.getSize(), -1)  // 流式传输
                .contentType(file.getContentType())
                .build()
        );
    }
    return Result.success();
}
```

**优势：**
- **内存占用恒定**：无论文件多大，内存占用都在几MB以内
- **支持大文件**：可以上传GB级别的文件
- **简单高效**：不需要分块、合并等复杂逻辑

**配置文件大小限制：**
```yaml
# application.yml
spring:
  servlet:
    multipart:
      max-file-size: 500MB      # 单个文件最大500MB
      max-request-size: 500MB   # 单次请求最大500MB
```

```nginx
# nginx.conf
client_max_body_size 500m;      # 允许上传500MB
client_body_timeout 300s;       # 上传超时时间5分钟
```

##### 3.8.1.3 Nginx限流防止并发过载

**问题：**
- 100个用户同时上传，所有请求同时到达后端
- 后端线程池、网络带宽瞬间耗尽

**解决方案：Nginx层面限流**
```nginx
http {
    # 1. 限制每个IP的并发连接数
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;

    # 2. 限制每个IP的请求速率
    limit_req_zone $binary_remote_addr zone=req_limit:10m rate=10r/s;

    server {
        listen 80;

        location /api/files/upload {
            # 每个IP最多5个并发连接
            limit_conn conn_limit 5;

            # 每秒最多10个请求，突发允许20个
            limit_req zone=req_limit burst=20 nodelay;

            # 限制上传速度：10MB/s
            limit_rate 10m;

            proxy_pass http://backend:8080;
        }
    }
}
```

**效果：**
- **削峰填谷**：将100个并发请求排队处理
- **保护后端**：后端同时只处理有限的上传请求
- **用户体验**：超出限制的请求排队等待，而不是直接失败

##### 3.8.1.4 RabbitMQ异步处理文件后续操作

**问题：**
- 文件上传后需要：更新存储统计、生成缩略图（如果是图片）等
- 这些操作耗时，同步处理会阻塞用户请求

**解决方案：异步处理**
```java
@Service
public class FileUploadService {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public Result uploadFile(MultipartFile file) {
        // 1. 上传文件到MinIO（快速）
        String fileUrl = minioUtil.uploadFile(file);

        // 2. 创建文件记录（快速）
        FileVersion fileVersion = new FileVersion();
        fileVersion.setFileUrl(fileUrl);
        fileVersionMapper.insert(fileVersion);

        // 3. 发送消息到MQ，异步处理后续任务（不阻塞）
        FileProcessMessage message = new FileProcessMessage();
        message.setFileId(fileVersion.getId());
        message.setFileUrl(fileUrl);
        rabbitTemplate.convertAndSend("file.process.queue", message);

        // 4. 立即返回，不等待后续处理
        return Result.success("文件上传成功");
    }
}

// 消费者：异步处理文件
@Component
public class FileProcessConsumer {

    @RabbitListener(queues = "file.process.queue", concurrency = "3-5")
    public void processFile(FileProcessMessage message) {
        // 1. 生成缩略图（如果是图片）
        if (isImage(message.getFileUrl())) {
            generateThumbnail(message.getFileId());
        }

        // 2. 更新租户存储统计（使用Redis）
        redisUtil.increment("tenant:storage:" + tenantId, fileSize);
    }
}
```

**RabbitMQ配置：**
```java
@Configuration
public class RabbitMQConfig {

    @Bean
    public Queue fileProcessQueue() {
        return QueueBuilder.durable("file.process.queue")
            .withArgument("x-max-length", 10000)  // 队列最大长度
            .build();
    }

    @Bean
    public DirectExchange fileExchange() {
        return new DirectExchange("file.exchange");
    }

    @Bean
    public Binding binding() {
        return BindingBuilder.bind(fileProcessQueue())
            .to(fileExchange())
            .with("file.process");
    }
}
```

**优势：**
- **快速响应**：用户上传后立即返回，不需要等待后续处理
- **削峰填谷**：高峰期的任务排队处理，不会压垮系统
- **提高吞吐量**：后端线程快速释放，可以处理更多上传请求

##### 3.8.1.5 性能提升总结

**内存优化：**
- 采用流式传输后，无论文件多大，内存占用恒定在几MB
- 100个并发上传从20GB内存降低到几百MB

**并发控制：**
- Nginx限流：每个IP最多5个并发连接
- 请求排队：削峰填谷，保护后端不被压垮

**响应速度：**
- 异步处理后续任务，用户上传后立即返回
- 响应时间从数秒降低到毫秒级

#### 3.8.2 版本文件复制优化方案（MD5去重）

##### 3.8.2.1 性能瓶颈分析

**场景描述：**
用户提交新版本时，需要复制上一版本的所有文件作为基础

**假设场景：**
- v1.0包含1000个文件，总计5GB
- 用户只修改了10个文件，提交v2.0
- 实际上990个文件完全没变，只是"复制"了一遍

**传统方案的性能瓶颈：**
1. **MinIO复制耗时**：
   - 需要复制全部1000个文件：约50秒
   - 其中990个文件内容完全相同，复制是浪费

2. **存储空间浪费**：
   - 相同文件在MinIO中存储多份
   - 10个版本 × 5GB = 50GB存储空间

3. **数据库写入压力**：
   - 1000次INSERT操作
   - 同步执行会阻塞用户请求

##### 3.8.2.2 MD5去重方案设计

**核心思路：**
- 使用MD5判断文件内容是否相同
- 相同MD5的文件，MinIO中只存储一份
- 版本复制时，只需创建数据库记录，指向同一个MinIO文件

**MinIO对象命名规则：**
```
格式：tenant_id/md5
示例：tenant_1/abc123def456789012345678901234

说明：
- 不包含文件扩展名，避免查找问题
- 相同MD5只存一个对象
- 租户隔离，不同租户的文件分开存储
```

**数据库字段：**
- `file_md5`：文件MD5值（32位字符串）
- `minio_object_name`：MinIO对象名（tenant_id/md5）
- `file_name`：原始文件名（用户看到的名称）
- `file_type`：文件扩展名（pdf、docx、png等）

##### 3.8.2.3 文件上传去重流程

**前端MD5计算优化（Web Worker）：**

为避免大文件MD5计算阻塞UI线程，使用Web Worker后台计算：

```javascript
// md5Worker.js - Web Worker文件
import SparkMD5 from 'spark-md5'

self.onmessage = function(e) {
  const file = e.data
  const chunkSize = 2 * 1024 * 1024  // 每次读取2MB
  const chunks = Math.ceil(file.size / chunkSize)
  const spark = new SparkMD5.ArrayBuffer()
  const fileReader = new FileReader()
  let currentChunk = 0

  fileReader.onload = function(e) {
    spark.append(e.target.result)
    currentChunk++

    // 发送进度
    self.postMessage({
      type: 'progress',
      progress: Math.floor((currentChunk / chunks) * 100)
    })

    if (currentChunk < chunks) {
      loadNext()
    } else {
      // 计算完成
      self.postMessage({
        type: 'complete',
        md5: spark.end()
      })
    }
  }

  fileReader.onerror = function() {
    self.postMessage({
      type: 'error',
      error: '文件读取失败'
    })
  }

  function loadNext() {
    const start = currentChunk * chunkSize
    const end = Math.min(start + chunkSize, file.size)
    fileReader.readAsArrayBuffer(file.slice(start, end))
  }

  loadNext()
}
```

```javascript
// 前端上传组件中使用Worker计算MD5
async function calculateFileMD5(file) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('/workers/md5Worker.js')

    worker.postMessage(file)

    worker.onmessage = function(e) {
      if (e.data.type === 'progress') {
        // 更新进度条：计算文件指纹 xx%
        updateProgress(e.data.progress)
      } else if (e.data.type === 'complete') {
        worker.terminate()
        resolve(e.data.md5)
      } else if (e.data.type === 'error') {
        worker.terminate()
        reject(new Error(e.data.error))
      }
    }
  })
}
```

**前端上传流程：**
```javascript
async function uploadFile(file, versionId) {
  try {
    // 1. 使用Web Worker计算文件MD5（不阻塞UI）
    const md5 = await calculateFileMD5(file)

    // 2. 检查文件是否已存在
    const { exists, objectName } = await api.checkFileExists(md5)

    if (exists) {
      // 文件已存在，秒传
      await api.createFileRecord({
        versionId: versionId,
        fileName: file.name,
        fileSize: file.size,
        fileType: getFileExtension(file.name),
        fileMd5: md5,
        minioObjectName: objectName
      })
      return { success: true, message: '文件已存在，秒传成功' }
    } else {
      // 文件不存在，上传
      const formData = new FormData()
      formData.append('file', file)
      formData.append('md5', md5)
      formData.append('fileName', file.name)
      formData.append('versionId', versionId)
      await api.uploadFile(formData)
      return { success: true, message: '文件上传成功' }
    }
  } catch (error) {
    console.error('上传失败:', error)
    return { success: false, message: error.message }
  }
}
```

**优势：**
- **不阻塞UI**：MD5计算在Worker线程，不影响页面交互
- **显示进度**：实时显示"计算文件指纹 XX%"
- **分片计算**：2MB分片，内存占用小
- **适用大文件**：200MB文件计算约2-5秒

**后端接口：**
```java
/**
 * 检查文件是否已存在（根据MD5）
 */
@GetMapping("/files/check")
public Result checkFileExists(@RequestParam("md5") String md5) {
    Long tenantId = getCurrentTenantId();

    ReviewFile existingFile = fileMapper.selectOne(
        new QueryWrapper<ReviewFile>()
            .eq("tenant_id", tenantId)
            .eq("file_md5", md5)
            .last("LIMIT 1")
    );

    if (existingFile != null) {
        return Result.success(Map.of(
            "exists", true,
            "objectName", existingFile.getMinioObjectName()
        ));
    } else {
        return Result.success(Map.of("exists", false));
    }
}

/**
 * 上传文件
 */
@PostMapping("/files/upload")
@Transactional
public Result uploadFile(
    @RequestParam("file") MultipartFile file,
    @RequestParam("md5") String md5,
    @RequestParam("fileName") String fileName,
    @RequestParam("versionId") Long versionId) {

    Long tenantId = getCurrentTenantId();
    String minioObjectName;
    boolean isNewUpload = false;

    // 检查版本下文件名是否重复
    Long count = fileMapper.selectCount(
        new QueryWrapper<ReviewFile>()
            .eq("version_id", versionId)
            .eq("file_name", fileName)
    );
    if (count > 0) {
        return Result.error("该版本下已存在同名文件");
    }

    // 再次检查MD5是否已存在（防止并发）
    ReviewFile existingFile = fileMapper.selectOne(
        new QueryWrapper<ReviewFile>()
            .eq("tenant_id", tenantId)
            .eq("file_md5", md5)
            .last("LIMIT 1")
    );

    if (existingFile != null) {
        // 复用现有文件
        minioObjectName = existingFile.getMinioObjectName();
    } else {
        // 上传到MinIO
        minioObjectName = tenantId + "/" + md5;
        minioUtil.uploadFile(file.getInputStream(), minioObjectName);
        isNewUpload = true;

        // 更新租户存储使用量
        tenantMapper.increaseStorageUsed(tenantId, file.getSize());
    }

    // 创建文件记录
    ReviewFile reviewFile = new ReviewFile();
    reviewFile.setTenantId(tenantId);
    reviewFile.setVersionId(versionId);
    reviewFile.setFileName(fileName);
    reviewFile.setFileSize(file.getSize());
    reviewFile.setFileType(FileUtil.getExtension(fileName));
    reviewFile.setFileMd5(md5);
    reviewFile.setMinioObjectName(minioObjectName);
    fileMapper.insert(reviewFile);

    return Result.success(Map.of(
        "fileId", reviewFile.getId(),
        "isNewUpload", isNewUpload
    ));
}
```

##### 3.8.2.4 版本复制流程（极速复制）

**核心逻辑：**
只创建数据库记录，不复制MinIO文件

**实现代码：**
```java
@Component
public class FileCopyConsumer {

    @Autowired
    private ReviewFileMapper fileMapper;

    @Autowired
    private ReviewVersionMapper versionMapper;

    @RabbitListener(queues = "file.copy.queue")
    public void copyFiles(FileCopyMessage message) {
        Long oldVersionId = message.getOldVersionId();
        Long newVersionId = message.getNewVersionId();

        // 1. 查询旧版本的所有文件
        List<ReviewFile> oldFiles = fileMapper.selectByVersionId(oldVersionId);

        // 2. 批量创建新记录
        List<ReviewFile> newFiles = new ArrayList<>();
        for (ReviewFile oldFile : oldFiles) {
            ReviewFile newFile = new ReviewFile();
            newFile.setTenantId(oldFile.getTenantId());
            newFile.setVersionId(newVersionId);
            newFile.setFileName(oldFile.getFileName());
            newFile.setFileSize(oldFile.getFileSize());
            newFile.setFileType(oldFile.getFileType());
            newFile.setFileMd5(oldFile.getFileMd5());              // 相同MD5
            newFile.setMinioObjectName(oldFile.getMinioObjectName()); // 指向同一MinIO文件
            newFiles.add(newFile);
        }

        // 3. 批量插入（不复制MinIO文件）
        if (!newFiles.isEmpty()) {
            fileMapper.insertBatch(newFiles);
        }

        // 4. 更新版本状态
        ReviewVersion version = versionMapper.selectById(newVersionId);
        version.setFilesReady(1);
        version.setFileCount(newFiles.size());
        versionMapper.updateById(version);

        log.info("版本复制完成，共{}个文件，耗时不到1秒", newFiles.size());
    }
}
```

**性能对比：**
- 传统方案：复制1000个文件到MinIO，耗时约50秒
- MD5去重：只插入1000条数据库记录，耗时约1秒
- 性能提升：50倍

##### 3.8.2.5 文件删除流程

**策略：只做逻辑删除，MinIO文件保留**

```java
@Service
public class FileService {

    /**
     * 删除文件（逻辑删除）
     */
    public void deleteFile(Long fileId) {
        fileVersionMapper.updateDeleted(fileId, 1);
        // MinIO文件保留，不删除
    }
}
```

**原因：**
- MD5去重后，相同文件只存一份
- 删除某个记录不影响其他记录
- 可以恢复误删的文件
- 存储空间不会浪费（已经去重了）

##### 3.8.2.6 性能提升总结

**文件上传：**
- 重复文件秒传，不需要重复上传
- 节省网络带宽和时间

**版本复制：**
- 1000个文件从50秒降到1秒
- 性能提升50倍

**存储空间：**
- 相同文件只存一份
- 10个版本，如果90%文件相同，存储空间从50GB降到5GB
- 节省90%存储空间

**MinIO访问：**
- 通过对象名直接访问，O(1)时间复杂度
- 无论有1个还是100万个对象，速度一样快

#### 3.8.3 文件下载/预览性能优化

##### 3.8.3.1 性能瓶颈分析

**传统方案：后端代理下载**
```
用户 → 后端 → MinIO → 后端 → 用户
```

**问题：**
- 100个用户同时下载200MB文件 = 20GB流量经过后端
- 后端成为瓶颈，占用带宽和内存
- 后端服务器压力大

##### 3.8.3.2 MinIO预签名URL方案

**优化方案：用户直连MinIO**
```
用户 → 后端（获取预签名URL，轻量请求）
用户 → MinIO（直接下载）
```

**后端实现：**
```java
@RestController
@RequestMapping("/api/files")
public class FileController {

    @Autowired
    private FileVersionMapper fileVersionMapper;

    @Autowired
    private MinioUtil minioUtil;

    /**
     * 获取文件下载URL
     */
    @GetMapping("/{fileId}/download-url")
    public Result getDownloadUrl(@PathVariable Long fileId) {
        // 1. 查询文件信息
        FileVersion fileVersion = fileVersionMapper.selectById(fileId);
        if (fileVersion == null || fileVersion.getDeleted() == 1) {
            return Result.error("文件不存在");
        }

        // 2. 生成预签名URL（有效期1小时）
        String presignedUrl = minioUtil.getPresignedUrl(
            fileVersion.getMinioObjectName(),
            3600  // 3600秒 = 1小时
        );

        // 3. 返回下载信息
        return Result.success(Map.of(
            "downloadUrl", presignedUrl,
            "fileName", fileVersion.getFileName(),
            "fileSize", fileVersion.getFileSize()
        ));
    }

    /**
     * 获取文件预览URL（用于浏览器预览PDF、图片等）
     */
    @GetMapping("/{fileId}/preview-url")
    public Result getPreviewUrl(@PathVariable Long fileId) {
        FileVersion fileVersion = fileVersionMapper.selectById(fileId);
        if (fileVersion == null || fileVersion.getDeleted() == 1) {
            return Result.error("文件不存在");
        }

        // 预览URL，有效期1小时
        String presignedUrl = minioUtil.getPresignedUrl(
            fileVersion.getMinioObjectName(),
            3600
        );

        return Result.success(Map.of(
            "previewUrl", presignedUrl,
            "fileName", fileVersion.getFileName(),
            "fileType", fileVersion.getFileType()
        ));
    }
}
```

**MinioUtil工具类：**
```java
@Component
public class MinioUtil {

    @Autowired
    private MinioClient minioClient;

    @Value("${minio.bucket-name}")
    private String bucketName;

    /**
     * 生成预签名下载URL
     * @param objectName MinIO对象名
     * @param expirySeconds 有效期（秒）
     * @return 预签名URL
     */
    public String getPresignedUrl(String objectName, int expirySeconds) {
        try {
            return minioClient.getPresignedObjectUrl(
                GetPresignedObjectUrlArgs.builder()
                    .method(Method.GET)
                    .bucket(bucketName)
                    .object(objectName)
                    .expiry(expirySeconds)
                    .build()
            );
        } catch (Exception e) {
            throw new RuntimeException("生成预签名URL失败", e);
        }
    }
}
```

**前端使用：**
```javascript
// 下载文件
async function downloadFile(fileId) {
  // 1. 获取下载URL
  const response = await api.getDownloadUrl(fileId);
  const { downloadUrl, fileName } = response.data;

  // 2. 创建隐藏的a标签，触发下载
  const link = document.createElement('a');
  link.href = downloadUrl;
  link.download = fileName;
  link.click();
}

// 预览文件（PDF、图片等）
async function previewFile(fileId) {
  const response = await api.getPreviewUrl(fileId);
  const { previewUrl } = response.data;

  // 在新窗口打开预览
  window.open(previewUrl, '_blank');
}
```

##### 3.8.3.3 安全性说明

**预签名URL的安全性：**
- URL包含临时签名，无需暴露MinIO的access key
- URL有过期时间（如1小时），过期自动失效
- 权限控制在后端：只有通过后端验证的用户才能获取URL
- MinIO验证签名的有效性

**权限控制：**
```java
@GetMapping("/{fileId}/download-url")
public Result getDownloadUrl(@PathVariable Long fileId, @CurrentUser User user) {
    FileVersion fileVersion = fileVersionMapper.selectById(fileId);

    // 检查用户是否有权限下载此文件
    if (!hasPermission(user, fileVersion)) {
        return Result.error("无权限访问此文件");
    }

    // 生成预签名URL
    String presignedUrl = minioUtil.getPresignedUrl(
        fileVersion.getMinioObjectName(), 3600
    );

    return Result.success(Map.of("downloadUrl", presignedUrl));
}
```

##### 3.8.3.4 性能对比

**场景：100个用户同时下载200MB文件**

**传统方案（后端代理）：**
- 后端需要中转：100 × 200MB = 20GB流量
- 后端带宽占用：20GB
- 后端内存占用：高（需要缓冲）
- 其他API响应变慢

**优化方案（预签名URL）：**
- 后端只生成URL：100个轻量请求，几乎无压力
- 后端带宽占用：几KB（只返回URL）
- 用户直接从MinIO下载：20GB流量不经过后端
- 其他API不受影响

**性能提升：**
- 后端压力：减少99%
- 支持并发数：提升10倍以上
- 下载速度：用户直连MinIO，更快

#### 3.8.4 数据库性能优化

##### 3.8.4.1 性能瓶颈分析

**查询性能瓶颈：**

**场景1：文件列表查询**
```sql
-- 查询某个版本的所有文件
SELECT * FROM review_file
WHERE version_id = 123 AND deleted = 0
ORDER BY file_path
LIMIT 100;
```
- 问题：涉及多表关联（project → version → file_version）
- 缺少索引导致全表扫描
- 大数据量时分页查询慢

**场景2：租户文件统计**
```sql
-- 统计租户的文件数量和存储大小
SELECT COUNT(*), SUM(file_size)
FROM review_file
WHERE tenant_id = 1 AND deleted = 0;
```
- 问题：每次都需要全表扫描计算
- 高并发查询时数据库压力大

**并发写入瓶颈：**

**场景：存储统计更新**
```sql
-- 多个用户同时上传文件，更新租户存储统计
UPDATE review_tenant
SET used_storage = used_storage + 200000000
WHERE id = 1;
```
- 问题：行锁竞争，导致串行执行
- 性能随并发数增加急剧下降

##### 3.8.4.2 索引优化方案

**核心原则：为高频查询添加合适的联合索引**

**1. 文件表索引优化**
```sql
-- 已有索引（参考数据库设计章节）
CREATE INDEX idx_version_id ON review_file(version_id);
CREATE INDEX idx_tenant_deleted ON review_file(tenant_id, deleted);
CREATE INDEX idx_file_md5 ON review_file(file_md5);
CREATE INDEX idx_tenant_md5_deleted ON review_file(tenant_id, file_md5, deleted);

-- 版本文件路径唯一约束（同时作为索引）
CREATE UNIQUE INDEX uk_version_filepath ON review_file(version_id, file_path);
```

**2. 版本表索引优化**
```sql
CREATE INDEX idx_project_id ON review_version(project_id);
CREATE INDEX idx_version_no ON review_version(version_no);
CREATE INDEX idx_status ON review_version(status);
```

**3. 项目表索引优化**
```sql
CREATE INDEX idx_tenant_id ON review_project(tenant_id);
CREATE INDEX idx_created_time ON review_project(created_time);
```

**索引使用验证：**
```sql
-- 使用EXPLAIN分析查询计划
EXPLAIN SELECT * FROM review_file
WHERE version_id = 123 AND deleted = 0;

-- 正确使用索引的特征：
-- type = ref 或 range（而不是ALL）
-- key = idx_version_id（使用了索引）
-- rows 较小（扫描行数少）
```

##### 3.8.4.3 查询优化方案

**1. 使用MyBatis-Plus分页插件**

**配置分页插件：**
```java
@Configuration
public class MyBatisPlusConfig {

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

        // 分页插件
        PaginationInnerInterceptor paginationInterceptor =
            new PaginationInnerInterceptor(DbType.MYSQL);
        paginationInterceptor.setMaxLimit(500L);  // 单页最大500条

        interceptor.addInnerInterceptor(paginationInterceptor);
        return interceptor;
    }
}
```

**使用分页查询：**
```java
@Service
public class FileVersionService {

    @Autowired
    private FileVersionMapper fileVersionMapper;

    /**
     * 分页查询版本文件
     */
    public IPage<FileVersion> getFilesByVersion(Long versionId, int pageNo, int pageSize) {
        Page<FileVersion> page = new Page<>(pageNo, pageSize);

        LambdaQueryWrapper<FileVersion> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(FileVersion::getVersionId, versionId)
               .eq(FileVersion::getDeleted, 0)
               .orderByAsc(FileVersion::getFilePath);

        return fileVersionMapper.selectPage(page, wrapper);
    }
}
```

**2. 避免SELECT * **

**不推荐：**
```java
// 查询所有字段，浪费网络传输和内存
List<FileVersion> files = fileVersionMapper.selectList(wrapper);
```

**推荐：**
```java
// 只查询需要的字段
LambdaQueryWrapper<FileVersion> wrapper = new LambdaQueryWrapper<>();
wrapper.select(FileVersion::getId, FileVersion::getFileName,
               FileVersion::getFileSize, FileVersion::getCreatedTime)
       .eq(FileVersion::getVersionId, versionId);
```

**3. 批量操作优化**

**使用MyBatis-Plus批量插入：**
```java
// 版本复制时批量插入文件记录
List<FileVersion> newFiles = new ArrayList<>();
// ... 构造newFiles列表

// 批量插入，每批500条
fileVersionService.saveBatch(newFiles, 500);
```

**批量更新：**
```java
// 批量更新文件状态
List<FileVersion> filesToUpdate = new ArrayList<>();
// ... 设置文件状态

fileVersionService.updateBatchById(filesToUpdate, 500);
```

##### 3.8.4.4 数据库连接池配置

**HikariCP配置优化：**
```yaml
# application.yml
spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      # 连接池配置
      minimum-idle: 10              # 最小空闲连接数
      maximum-pool-size: 50         # 最大连接数
      connection-timeout: 30000     # 连接超时时间30秒
      idle-timeout: 600000          # 空闲连接超时时间10分钟
      max-lifetime: 1800000         # 连接最大生命周期30分钟

      # 连接测试
      connection-test-query: SELECT 1

      # 性能优化
      auto-commit: true
      pool-name: FileReviewHikariCP
```

**连接池大小计算：**
```
推荐连接数 = ((核心数 * 2) + 磁盘数)

示例：4核CPU + 1个磁盘 = (4 * 2) + 1 = 9
建议设置：minimum-idle = 10, maximum-pool-size = 50
```

##### 3.8.4.5 性能提升总结

**查询性能：**
- 添加合适索引后，查询时间从秒级降到毫秒级
- 分页查询避免一次加载大量数据，内存占用减少90%

**批量操作：**
- 1000条INSERT从10秒降到1秒（使用saveBatch）
- 数据库交互次数从1000次降到2次

**并发写入：**
- 存储统计使用Redis后（见3.8.5章节），数据库UPDATE操作减少99%
- 行锁竞争基本消除

**连接池：**
- 合理配置连接池，避免连接耗尽导致请求阻塞
- 连接复用，减少创建销毁开销

#### 3.8.5 Redis缓存优化

##### 3.8.5.1 性能瓶颈分析

**场景：租户存储统计并发更新**

当多个用户同时上传文件时，需要更新租户的存储统计：

**传统方案（数据库UPDATE）：**
```sql
-- 用户A上传200MB文件
UPDATE review_tenant
SET used_storage = used_storage + 200000000
WHERE id = 1;

-- 用户B上传150MB文件（同一租户）
UPDATE review_tenant
SET used_storage = used_storage + 150000000
WHERE id = 1;

-- 用户C上传300MB文件（同一租户）
UPDATE review_tenant
SET used_storage = used_storage + 300000000
WHERE id = 1;
```

**问题分析：**
- 10个用户同时上传，10个UPDATE操作竞争同一行锁
- 数据库强制串行执行：用户A → 等待 → 用户B → 等待 → 用户C...
- TPS（每秒事务数）= 1000 ÷ 10 = 100（假设单次UPDATE 1ms）
- 随着并发增加，性能急剧下降

**性能测试数据：**
```
并发数10：平均响应时间 10ms
并发数50：平均响应时间 50ms
并发数100：平均响应时间 100ms（行锁等待）
并发数200：平均响应时间 200ms（严重阻塞）
```

##### 3.8.5.2 Redis原子计数方案

**核心思路：**
- 使用Redis的INCR/INCRBY命令进行原子计数
- Redis单线程模型，天然支持高并发
- 定时将Redis数据同步回数据库

**实现方案：**

**1. Spring Boot Redis配置**
```yaml
# application.yml
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 50    # 最大连接数
        max-idle: 20      # 最大空闲连接
        min-idle: 5       # 最小空闲连接
        max-wait: 3000ms  # 连接等待时间
```

**2. Redis持久化配置（重要）**

虽然有定时同步机制，但仍建议配置Redis持久化，双重保险。

**Redis持久化方式对比：**

| 特性 | RDB（快照） | AOF（追加日志） | 推荐配置 |
|------|------------|----------------|----------|
| 持久化方式 | 定期保存内存快照 | 记录每个写操作 | RDB + AOF |
| 数据完整性 | 可能丢失两次快照间的数据 | 最多丢失1秒数据 | AOF更安全 |
| 恢复速度 | 快（直接加载） | 慢（需要回放日志） | RDB更快 |
| 文件大小 | 小（压缩） | 大（记录所有操作） | RDB更小 |
| 性能影响 | 小（异步fork） | 中等（每秒fsync） | RDB影响小 |

**RDB配置（redis.conf）：**
```conf
# RDB持久化：定期保存快照到磁盘
save 900 1      # 15分钟内至少1次写入，保存快照
save 300 10     # 5分钟内至少10次写入，保存快照
save 60 10000   # 1分钟内至少10000次写入，保存快照

# RDB文件名
dbfilename dump.rdb

# 数据目录
dir /var/lib/redis

# RDB压缩
rdbcompression yes

# RDB校验
rdbchecksum yes
```

**RDB工作原理：**
```
时间轴示例：
10:00 - Redis开始运行
10:01 - 10次写入，触发 save 60 10000？否，继续
10:05 - 累计100次写入，触发 save 300 10？否（未到300秒）
10:06 - 累计10000次写入，触发 save 60 10000，执行RDB快照
       → fork子进程，异步保存内存数据到 dump.rdb
10:20 - 累计100次写入，触发 save 300 10，再次保存快照
```

**AOF配置（redis.conf）：**
```conf
# 启用AOF持久化
appendonly yes

# AOF文件名
appendfilename "appendonly.aof"

# AOF同步策略（重要）
appendfsync everysec    # 推荐：每秒同步一次，性能和安全的平衡
# appendfsync always    # 最安全：每次写入都同步，性能差
# appendfsync no        # 最快：由操作系统决定何时同步，可能丢失数据

# AOF重写（压缩日志文件）
auto-aof-rewrite-percentage 100  # AOF文件大小增长100%时重写
auto-aof-rewrite-min-size 64mb   # AOF文件至少64MB才重写

# 数据目录
dir /var/lib/redis
```

**AOF工作原理：**
```
时间轴示例（appendfsync everysec）：
10:00:00.000 - SET key1 value1  → 写入AOF缓冲区
10:00:00.100 - INCR counter     → 写入AOF缓冲区
10:00:00.500 - SET key2 value2  → 写入AOF缓冲区
10:00:01.000 - fsync到磁盘（将1秒内的所有操作刷入磁盘）
10:00:01.200 - INCR counter     → 写入AOF缓冲区
10:00:02.000 - fsync到磁盘

如果10:00:01.500服务器宕机：
- 10:00:01.000之前的数据已保存到磁盘，可恢复
- 10:00:01.200的操作在缓冲区，丢失
- 最多丢失1秒数据
```

**推荐生产配置（同时启用RDB和AOF）：**
```conf
# redis.conf

# 1. RDB配置（快速恢复）
save 300 10
save 60 10000
dbfilename dump.rdb
rdbcompression yes

# 2. AOF配置（数据安全）
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec

# 3. 数据目录
dir /data/redis

# 4. 内存管理
maxmemory 2gb
maxmemory-policy allkeys-lru  # 内存满时删除最少使用的key
```

**Redis启动恢复优先级：**
```
1. 检查是否存在 appendonly.aof
   - 存在：从AOF恢复（数据最完整）
   - 不存在：继续下一步
2. 检查是否存在 dump.rdb
   - 存在：从RDB恢复
   - 不存在：空数据启动
```

**三重保险机制：**
```
数据丢失的可能性：
- 仅依赖定时同步：最多丢失1分钟数据（Redis完全故障）
- 配置AOF：最多丢失1秒数据（服务器宕机）
- AOF + 定时同步：几乎不会丢失数据
  → Redis故障时从AOF恢复
  → AOF丢失时从数据库恢复
```

**3. Redis工具类**
```java
@Component
public class RedisUtil {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * 增加存储统计（原子操作）
     */
    public Long incrementStorage(Long tenantId, Long bytes) {
        String key = "tenant:storage:" + tenantId;
        return redisTemplate.opsForValue().increment(key, bytes);
    }

    /**
     * 减少存储统计（删除文件时）
     */
    public Long decrementStorage(Long tenantId, Long bytes) {
        String key = "tenant:storage:" + tenantId;
        return redisTemplate.opsForValue().increment(key, -bytes);
    }

    /**
     * 获取当前存储统计
     */
    public Long getStorage(Long tenantId) {
        String key = "tenant:storage:" + tenantId;
        String value = redisTemplate.opsForValue().get(key);
        return value != null ? Long.parseLong(value) : 0L;
    }

    /**
     * 初始化存储统计（从数据库加载）
     */
    public void initStorage(Long tenantId, Long usedStorage) {
        String key = "tenant:storage:" + tenantId;
        redisTemplate.opsForValue().set(key, String.valueOf(usedStorage));
    }
}
```

**4. 文件上传时更新Redis**
```java
@Service
public class FileUploadService {

    @Autowired
    private RedisUtil redisUtil;

    @Autowired
    private FileVersionMapper fileVersionMapper;

    public Result uploadFile(MultipartFile file, Long tenantId, Long versionId) {
        // 1. 上传文件到MinIO
        String minioObjectName = minioUtil.uploadFile(file);

        // 2. 保存文件记录
        FileVersion fileVersion = new FileVersion();
        fileVersion.setTenantId(tenantId);
        fileVersion.setFileSize(file.getSize());
        fileVersion.setMinioObjectName(minioObjectName);
        fileVersionMapper.insert(fileVersion);

        // 3. 更新Redis存储统计（原子操作，无锁）
        Long currentStorage = redisUtil.incrementStorage(tenantId, file.getSize());

        log.info("租户{}上传文件，大小{}字节，当前总存储{}字节",
                 tenantId, file.getSize(), currentStorage);

        return Result.success();
    }
}
```

**5. 文件删除时更新Redis**
```java
@Service
public class FileService {

    @Autowired
    private RedisUtil redisUtil;

    public void deleteFile(Long fileId) {
        // 1. 查询文件信息
        FileVersion file = fileVersionMapper.selectById(fileId);

        // 2. 逻辑删除
        fileVersionMapper.updateDeleted(fileId, 1);

        // 3. 减少Redis存储统计
        redisUtil.decrementStorage(file.getTenantId(), file.getFileSize());
    }
}
```

##### 3.8.5.3 定时同步到数据库

**为什么需要同步：**
- Redis数据在内存中，可能丢失（重启、故障）
- 数据库是持久化存储，需要定期同步保证数据一致性

**数据一致性优先级策略（重要）：**

系统重启时，Redis和数据库可能存在数据不一致的情况，需要明确优先级：

**优先级规则：**
```
Redis有数据（AOF恢复） > 数据库数据 > 空数据
```

**策略说明：**
1. **Redis有数据**：说明AOF恢复成功，保留Redis数据（可能是最新的）
2. **Redis无数据**：AOF丢失或首次启动，从数据库恢复
3. **都无数据**：初始化为0

**定时任务实现：**
```java
@Component
public class StorageSyncTask {

    @Autowired
    private RedisUtil redisUtil;

    @Autowired
    private TenantMapper tenantMapper;

    /**
     * 每1分钟同步一次Redis数据到数据库
     */
    @Scheduled(fixedRate = 60000)  // 每60秒执行一次
    public void syncStorageToDatabase() {
        log.info("开始同步存储统计到数据库");

        List<Tenant> tenants = tenantMapper.selectList(null);

        for (Tenant tenant : tenants) {
            Long redisStorage = redisUtil.getStorage(tenant.getId());

            // 只有Redis有数据时才更新数据库
            if (redisStorage != null && redisStorage > 0) {
                tenantMapper.updateUsedStorage(tenant.getId(), redisStorage);
            }
        }

        log.info("存储统计同步完成，共{}个租户", tenants.size());
    }

    /**
     * 系统启动时，智能初始化Redis（优先使用Redis AOF恢复的数据）
     */
    @PostConstruct
    public void initRedisFromDatabase() {
        log.info("开始初始化Redis存储统计");

        List<Tenant> tenants = tenantMapper.selectList(null);
        int initCount = 0;
        int skipCount = 0;

        for (Tenant tenant : tenants) {
            // 1. 检查Redis是否已有数据（可能是AOF恢复的）
            Long redisStorage = redisUtil.getStorage(tenant.getId());

            if (redisStorage == null || redisStorage == 0) {
                // Redis无数据，从数据库初始化
                redisUtil.initStorage(tenant.getId(), tenant.getUsedStorage());
                initCount++;
                log.debug("租户{}从数据库初始化：{}字节",
                         tenant.getId(), tenant.getUsedStorage());
            } else {
                // Redis有数据（AOF恢复的），保留Redis数据
                skipCount++;
                log.debug("租户{}已有Redis数据：{}字节，跳过初始化",
                         tenant.getId(), redisStorage);
            }
        }

        log.info("Redis初始化完成，共{}个租户，初始化{}个，跳过{}个（Redis已有数据）",
                tenants.size(), initCount, skipCount);
    }
}
```

**Mapper方法：**
```java
@Mapper
public interface TenantMapper extends BaseMapper<Tenant> {

    /**
     * 更新租户存储统计
     */
    @Update("UPDATE review_tenant SET used_storage = #{usedStorage} WHERE id = #{tenantId}")
    void updateUsedStorage(@Param("tenantId") Long tenantId,
                          @Param("usedStorage") Long usedStorage);
}
```

**启用定时任务：**
```java
@SpringBootApplication
@EnableScheduling  // 启用定时任务
public class FileReviewApplication {
    public static void main(String[] args) {
        SpringApplication.run(FileReviewApplication.class, args);
    }
}
```

**场景分析：**

**场景1：正常重启（Redis AOF恢复成功）**
```
时间轴：
10:00 - Redis=100GB, 数据库=100GB
10:01 - 定时任务同步，两边都是100GB
10:01:30 - 用户上传10GB文件，Redis=110GB（写入AOF）
10:02 - 系统重启
  1. Redis从AOF恢复 → Redis=110GB
  2. @PostConstruct检查Redis → 发现有数据110GB
  3. 跳过初始化，保留Redis的110GB（最新数据）✓
  4. 下次定时任务（10:03）同步到数据库 → 数据库=110GB

结果：数据不丢失
```

**场景2：AOF损坏，RDB恢复**
```
时间轴：
10:00 - Redis=100GB, 数据库=100GB, RDB快照=100GB
10:01 - 定时任务同步，两边都是100GB
10:01:30 - 用户上传10GB，Redis=110GB（写入AOF）
10:02 - Redis AOF文件损坏，系统重启
  1. Redis尝试从AOF恢复 → 失败（文件损坏）
  2. Redis回退到RDB恢复 → 成功，Redis=100GB
  3. @PostConstruct检查Redis → 发现有数据100GB
  4. 跳过初始化，保留RDB恢复的100GB
  5. 丢失了10GB数据（RDB快照后上传的）

结果：丢失部分数据，但比完全丢失好
```

**场景3：AOF和RDB都损坏**
```
时间轴：
10:00 - Redis=100GB, 数据库=100GB
10:01 - 定时任务同步，两边都是100GB
10:01:30 - 用户上传10GB，Redis=110GB
10:02 - 磁盘故障，AOF和RDB都损坏，系统重启
  1. Redis无法从AOF恢复 → 失败
  2. Redis无法从RDB恢复 → 失败
  3. Redis为空
  4. @PostConstruct检查Redis → 无数据
  5. 从数据库恢复 → Redis=100GB
  6. 丢失了10GB数据（还没同步到数据库）

结果：丢失最多1分钟数据（可接受）
```

**场景4：首次启动**
```
1. Redis为空（首次启动）
2. @PostConstruct检查Redis → 无数据
3. 从数据库初始化 → Redis=数据库的值

结果：正常启动
```

**场景5：Redis和数据库都故障**
```
- Redis AOF和RDB都损坏
- 数据库也损坏（极低概率）
→ 需要从备份恢复

结果：极低概率，需要灾备方案
```

**Redis启动恢复完整流程：**
```
Redis启动时的恢复优先级（从高到低）：
1. AOF文件 → 存在且完整 → 从AOF恢复（数据最完整，最多丢1秒）
2. RDB文件 → AOF不可用时 → 从RDB恢复（快速恢复，丢失快照后的数据）
3. 数据库 → Redis都不可用 → 从MySQL恢复（最多丢失1分钟）
4. 空数据 → 都不可用 → 空数据启动

多层保障，数据安全性极高
```

**数据安全保障：**
```
四重保险机制：
1. Redis AOF持久化 → 最多丢失1秒数据
2. Redis RDB快照 → AOF损坏时的后备方案
3. 定时同步MySQL → 最多丢失1分钟数据
4. MySQL持久化 → 永久存储

数据完全丢失概率：需要AOF + RDB + MySQL同时损坏（几乎不可能）
```

##### 3.8.5.4 性能提升总结

**并发性能对比：**

**数据库UPDATE方案：**
```
并发10：TPS = 100
并发50：TPS = 50（行锁等待严重）
并发100：TPS = 20（几乎阻塞）
```

**Redis INCR方案：**
```
并发10：TPS = 10000
并发50：TPS = 10000
并发100：TPS = 10000（性能稳定）
并发1000：TPS = 8000（轻微下降）
```

**性能提升：**
- 并发写入性能提升：100倍以上
- 响应时间：从100ms降到1ms
- 无行锁竞争：Redis单线程模型，天然支持高并发

**数据一致性：**
- 实时性：Redis实时更新，查询即时准确
- 持久性：每1分钟同步到数据库
- 容错性：系统启动时从数据库恢复Redis数据

**适用场景：**
- 高并发计数：存储统计、访问次数、点赞数等
- 实时性要求高：需要立即看到最新数据
- 可接受短暂不一致：Redis和数据库之间有1分钟延迟

#### 3.8.6 性能测试方法

##### 3.8.6.1 性能合格标准

**不同配置服务器的性能指标：**

| 服务器配置 | 2核2G | 2核4G |
|-----------|-------|-------|
| **并发浏览用户** | 20-30人 | 50-80人 |
| **并发上传用户** | 2-3人 | 5-10人 |
| **总注册用户** | 100-150人 | 300-500人 |
| **适用团队规模** | 10-20人 | 50-100人 |
| **响应时间（P95）** | <2s | <1s |
| **CPU使用率** | <70% | <70% |
| **内存使用率** | <85% | <80% |
| **错误率** | <2% | <1% |

**说明：**
- 总注册用户 ≠ 同时在线用户
- 通常同时在线率：10-20%
- 100个用户，同时在线约10-20人

**核心性能指标（合格标准）：**

| 操作类型 | 2核2G合格标准 | 2核4G合格标准 | 说明 |
|---------|--------------|--------------|------|
| **文件列表查询** | <500ms | <300ms | P95响应时间 |
| **文件详情查询** | <200ms | <100ms | P95响应时间 |
| **文件上传50MB** | <60s | <40s | 4M带宽 |
| **文件下载50MB** | <60s | <40s | 4M带宽 |
| **版本复制1000文件** | <5s | <3s | 数据库批量插入 |
| **数据库查询** | <100ms | <50ms | 单表查询 |
| **Redis操作** | <5ms | <5ms | 单次操作 |

##### 3.8.6.2 测试工具选择

**推荐工具：**

**1. JMeter（推荐，功能强大）**
```bash
# 下载
https://jmeter.apache.org/download_jmeter.cgi

# 启动（Windows）
jmeter.bat

# 启动（Linux）
./jmeter.sh
```

**2. ApacheBench（简单快速）**
```bash
# 安装（Linux）
sudo apt install apache2-utils

# 使用
ab -n 1000 -c 10 http://your-server/api/files
```

**3. wrk（高性能）**
```bash
# 安装
sudo apt install wrk

# 使用
wrk -t4 -c100 -d30s http://your-server/api/files
```

##### 3.8.6.3 并发用户容量测试

**测试目的：** 确定服务器能承受多少并发用户

**测试场景：模拟真实用户行为**

**场景1：文件浏览（轻量操作）**
```
用户行为：
1. 登录系统（10%流量）
2. 查看项目列表（30%流量）
3. 查看文件列表（40%流量）
4. 查看文件详情（20%流量）

JMeter配置：
线程数：逐步增加（10 → 20 → 50 → 100）
循环次数：100次
Ramp-up时间：60秒（模拟用户陆续进入）
```

**JMeter测试脚本（文件浏览）：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2">
  <hashTree>
    <TestPlan>
      <stringProp name="TestPlan.comments">文件浏览并发测试</stringProp>
    </TestPlan>
    <hashTree>
      <!-- 线程组 -->
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup">
        <stringProp name="ThreadGroup.num_threads">${__P(threads,10)}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">60</stringProp>
        <longProp name="ThreadGroup.duration">300</longProp>
      </ThreadGroup>
      <hashTree>
        <!-- HTTP请求默认值 -->
        <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement">
          <stringProp name="HTTPSampler.domain">your-server</stringProp>
          <stringProp name="HTTPSampler.port">8080</stringProp>
        </ConfigTestElement>

        <!-- 查询文件列表 -->
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy">
          <stringProp name="HTTPSampler.path">/api/files?versionId=1&amp;page=1&amp;size=20</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
        </HTTPSamplerProxy>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```

**测试步骤：**
```bash
# 1. 测试10并发用户
jmeter -n -t test.jmx -Jthreads=10 -l result_10.jtl

# 2. 测试20并发用户
jmeter -n -t test.jmx -Jthreads=20 -l result_20.jtl

# 3. 测试50并发用户
jmeter -n -t test.jmx -Jthreads=50 -l result_50.jtl

# 4. 测试100并发用户（找到极限）
jmeter -n -t test.jmx -Jthreads=100 -l result_100.jtl
```

**合格标准判断：**
```
观察指标：
1. 响应时间（P95）< 2s（2核2G）或 < 1s（2核4G）
2. 错误率 < 2%（2核2G）或 < 1%（2核4G）
3. CPU使用率 < 70%
4. 内存使用率 < 85%（2核2G）或 < 80%（2核4G）

找到临界点：
- 2核2G：预期在20-30并发时达到临界点
- 2核4G：预期在50-80并发时达到临界点
```

**场景2：文件上传（重量操作）**
```
用户行为：
- 上传50MB文件

JMeter配置：
线程数：2, 3, 5, 10（逐步增加）
每个用户上传10个文件
```

**ApacheBench测试（简单API）：**
```bash
# 测试文件列表查询
# 1000个请求，10个并发
ab -n 1000 -c 10 \
   -H "Authorization: Bearer token" \
   http://your-server/api/files?versionId=1

# 查看结果
# Requests per second（QPS）
# Time per request（平均响应时间）
# 50%、95%、99%响应时间
```

##### 3.8.6.4 文件上传性能测试

**测试目的：** 验证文件上传性能和并发能力

**测试用例：**

**用例1：单用户上传大文件**
```bash
# 准备测试文件
dd if=/dev/zero of=test_50mb.bin bs=1M count=50
dd if=/dev/zero of=test_200mb.bin bs=1M count=200

# 测试50MB文件上传
curl -X POST http://your-server/api/files/upload \
  -F "file=@test_50mb.bin" \
  -F "versionId=1" \
  -F "filePath=/test/file.bin" \
  -w "Time: %{time_total}s\n"

# 合格标准：
# 2核2G：< 60秒
# 2核4G：< 40秒
```

**用例2：并发上传**
```bash
# JMeter并发上传测试
# 配置：
# - 线程数：2, 3, 5（逐步增加）
# - 文件大小：50MB
# - 持续时间：5分钟

# 观察：
# - 2核2G：2-3个并发上传时，响应时间开始明显增加
# - 2核4G：5-10个并发上传时，响应时间开始明显增加
```

**性能瓶颈分析：**
```bash
# 在服务器上监控
# 1. CPU使用率
top

# 2. 内存使用
free -h

# 3. 磁盘IO
iostat -x 1

# 4. 网络带宽
iftop
```

##### 3.8.6.5 版本复制性能测试

**测试目的：** 验证MD5去重方案的性能

**测试用例：复制1000个文件的版本**

**测试脚本：**
```bash
# 1. 准备数据：创建包含1000个文件的版本
curl -X POST http://your-server/api/versions \
  -H "Content-Type: application/json" \
  -d '{
    "projectId": 1,
    "versionNo": "v1.0",
    "description": "测试版本"
  }'

# 2. 上传1000个文件（可以用脚本批量上传）

# 3. 测试版本复制
time curl -X POST http://your-server/api/versions/copy \
  -H "Content-Type: application/json" \
  -d '{
    "oldVersionId": 1,
    "newVersionId": 2
  }'

# 合格标准：
# 2核2G：< 5秒
# 2核4G：< 3秒
```

**验证批量插入性能：**
```java
// 查看日志
// 应该看到类似输出：
// 版本复制完成，共1000个文件，耗时2.1秒
```

##### 3.8.6.6 数据库查询性能测试

**测试目的：** 验证索引优化效果

**测试用例1：文件列表查询**
```sql
-- 测试查询（带索引）
EXPLAIN SELECT * FROM review_file
WHERE version_id = 1 AND deleted = 0
ORDER BY file_path
LIMIT 20;

-- 检查：
-- type = ref（使用了索引）
-- rows 较小（扫描行数少）
```

**压测数据库：**
```bash
# 使用sysbench测试MySQL性能
sysbench --db-driver=mysql \
  --mysql-host=localhost \
  --mysql-user=root \
  --mysql-password=123456 \
  --mysql-db=file_review \
  --table-size=10000 \
  --tables=1 \
  --threads=10 \
  --time=60 \
  oltp_read_only prepare

sysbench --db-driver=mysql \
  --mysql-host=localhost \
  --mysql-user=root \
  --mysql-password=123456 \
  --mysql-db=file_review \
  --table-size=10000 \
  --tables=1 \
  --threads=10 \
  --time=60 \
  oltp_read_only run

# 合格标准：
# QPS > 500（2核2G）
# QPS > 1000（2核4G）
```

##### 3.8.6.7 Redis并发测试

**测试工具：redis-benchmark**

```bash
# 测试INCR性能（存储统计）
redis-benchmark -t incr -n 100000 -c 50

# 合格标准：
# QPS > 10000
# 平均延迟 < 5ms

# 测试GET/SET性能
redis-benchmark -t get,set -n 100000 -c 50 -d 100

# 对比数据库UPDATE的性能（模拟行锁）
# Redis INCR: 10000+ QPS
# MySQL UPDATE: 100-500 QPS
# 性能提升：20-100倍
```

##### 3.8.6.8 综合压力测试

**测试目的：** 模拟真实生产环境

**测试场景：混合操作**
```
用户行为分布：
- 60% 浏览文件列表
- 20% 查看文件详情
- 10% 上传文件
- 10% 下载文件

并发用户：
- 2核2G：测试10、20、30用户
- 2核4G：测试20、50、80用户
```

**JMeter配置（混合场景）：**
```xml
<!-- 线程组1：浏览用户（60%） -->
<ThreadGroup>
  <stringProp name="ThreadGroup.num_threads">12</stringProp>
  <elementProp name="ThreadGroup.main_controller">
    <LoopController>
      <!-- 查看文件列表 -->
      <HTTPSamplerProxy>
        <stringProp name="HTTPSampler.path">/api/files</stringProp>
      </HTTPSamplerProxy>
    </LoopController>
  </elementProp>
</ThreadGroup>

<!-- 线程组2：上传用户（10%） -->
<ThreadGroup>
  <stringProp name="ThreadGroup.num_threads">2</stringProp>
  <!-- 上传文件 -->
</ThreadGroup>
```

**合格标准（综合评估）：**

**2核2G服务器：**
```
并发用户：20人
- 响应时间P95 < 2s
- 错误率 < 2%
- CPU < 70%
- 内存 < 85%

结论：支持10-20人团队使用
```

**2核4G服务器：**
```
并发用户：50人
- 响应时间P95 < 1s
- 错误率 < 1%
- CPU < 70%
- 内存 < 80%

结论：支持50-100人团队使用
```

##### 3.8.6.9 性能测试报告模板

**测试报告格式：**

```markdown
## 性能测试报告

### 测试环境
- 服务器配置：2核4G
- 数据量：1000个文件，总计5GB
- 测试工具：JMeter 5.6
- 测试时间：2025-01-15

### 测试结果

#### 1. 并发浏览测试
| 并发数 | 平均响应时间 | P95响应时间 | 错误率 | QPS | CPU | 内存 |
|--------|-------------|------------|--------|-----|-----|------|
| 10     | 150ms       | 250ms      | 0%     | 65  | 35% | 60%  |
| 20     | 280ms       | 450ms      | 0%     | 70  | 50% | 65%  |
| 50     | 650ms       | 980ms      | 0.2%   | 75  | 68% | 72%  |
| 80     | 1200ms      | 1800ms     | 1.5%   | 65  | 75% | 78%  |

**结论：** 50并发时达到最佳性能，80并发时接近极限

#### 2. 文件上传测试
| 并发数 | 文件大小 | 平均耗时 | 成功率 |
|--------|---------|---------|--------|
| 1      | 50MB    | 35s     | 100%   |
| 3      | 50MB    | 42s     | 100%   |
| 5      | 50MB    | 55s     | 98%    |
| 10     | 50MB    | 78s     | 90%    |

**结论：** 最多支持5个用户同时上传

#### 3. 版本复制测试
- 文件数：1000个
- 耗时：2.3秒
- 成功率：100%

**结论：** 符合预期（< 3秒）

### 性能瓶颈
1. 文件上传并发受限于网络带宽（4M）
2. 80并发时CPU使用率达到75%

### 优化建议
1. 考虑升级到4核8G配置
2. 添加Nginx限流，保护后端

### 最终结论
✅ 当前配置（2核4G）可支持50人团队使用
```

##### 3.8.6.10 快速验收测试（5分钟）

**如果时间有限，执行快速验收：**

```bash
# 1. 文件列表查询（30秒）
ab -n 100 -c 10 http://your-server/api/files?versionId=1

# 检查：
# - Time per request < 500ms (2核2G) 或 < 300ms (2核4G)
# - Failed requests = 0

# 2. 文件上传（2分钟）
curl -X POST http://your-server/api/files/upload \
  -F "file=@test_50mb.bin" \
  -w "Time: %{time_total}s\n"

# 检查：
# - Time < 60s (2核2G) 或 < 40s (2核4G)

# 3. 版本复制（1分钟）
time curl -X POST http://your-server/api/versions/copy \
  -d '{"oldVersionId": 1, "newVersionId": 2}'

# 检查：
# - Time < 5s (2核2G) 或 < 3s (2核4G)

# 4. 系统资源（1分钟）
top  # CPU < 70%
free -h  # 内存使用率 < 85% (2核2G) 或 < 80% (2核4G)
```

**全部通过 = 性能合格 ✅**

## 4. API接口设计

### 4.1 接口规范

#### 4.1.1 RESTful规范

- 使用HTTP方法表示操作：GET（查询）、POST（创建）、PUT（更新）、DELETE（删除）
- URL使用名词复数形式
- 统一返回JSON格式
- 使用HTTP状态码

#### 4.1.2 请求头

```
Content-Type: application/json
Authorization: Bearer {token}
```

#### 4.1.3 统一响应格式

**成功响应：**

```json
{
  "code": "SUCCESS",
  "message": "操作成功",
  "data": { }
}
```

**失败响应：**

```json
{
  "code": "ERROR_CODE",
  "message": "错误信息",
  "data": null
}
```

**分页响应：**

```json
{
  "code": "SUCCESS",
  "message": "操作成功",
  "data": {
    "records": [],
    "total": 100,
    "currentPage": 1,
    "pageSize": 10
  }
}
```

### 4.2 认证接口

#### 4.2.1 用户登录

**接口地址：** `POST /api/auth/login`

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| username | String | 是 | 用户名 |
| password | String | 是 | 密码 |

**请求示例：**

```json
{
  "username": "admin",
  "password": "123456"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userInfo": {
      "id": 1,
      "username": "admin",
      "realName": "管理员",
      "tenantId": 1,
      "tenantName": "示例企业",
      "roles": ["TENANT_ADMIN"]
    }
  }
}
```

#### 4.2.2 修改密码

**接口地址：** `PUT /api/auth/password`

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| oldPassword | String | 是 | 原密码 |
| newPassword | String | 是 | 新密码，最少6位 |

**请求示例：**

```json
{
  "oldPassword": "123456",
  "newPassword": "654321"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "密码修改成功",
  "data": null
}
```

### 4.3 租户管理接口

#### 4.3.1 创建租户

**接口地址：** `POST /api/tenant`

**权限：** 平台超管

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| tenantName | String | 是 | 企业名称，全局唯一 |
| contactName | String | 是 | 联系人姓名 |
| contactPhone | String | 是 | 联系电话 |
| storageQuota | Integer | 否 | 存储配额（GB），默认100 |
| userQuota | Integer | 否 | 用户配额，默认50 |

**请求示例：**

```json
{
  "tenantName": "示例企业",
  "contactName": "张三",
  "contactPhone": "13800138000",
  "storageQuota": 100,
  "userQuota": 50
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "创建成功",
  "data": {
    "id": 1
  }
}
```

#### 4.3.2 查询租户列表

**接口地址：** `GET /api/tenant/list`

**权限：** 平台超管

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | Integer | 是 | 页码，从1开始 |
| pageSize | Integer | 是 | 每页数量 |
| status | Integer | 否 | 状态筛选：1-正常，0-停用 |
| keyword | String | 否 | 企业名称关键词搜索 |

**请求示例：**

```
GET /api/tenant/list?page=1&pageSize=10&status=1&keyword=示例
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "records": [
      {
        "id": 1,
        "tenantName": "示例企业",
        "contactName": "张三",
        "contactPhone": "13800138000",
        "storageQuota": 107374182400,
        "storageUsed": 1048576,
        "userQuota": 50,
        "userCount": 10,
        "status": 1,
        "createTime": "2025-01-01 10:00:00"
      }
    ],
    "total": 1,
    "currentPage": 1,
    "pageSize": 10
  }
}
```

#### 4.3.3 更新租户

**接口地址：** `PUT /api/tenant/{id}`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 租户ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| tenantName | String | 否 | 企业名称 |
| contactName | String | 否 | 联系人姓名 |
| contactPhone | String | 否 | 联系电话 |
| storageQuota | Integer | 否 | 存储配额（GB），不能小于已使用量 |
| userQuota | Integer | 否 | 用户配额，不能小于已创建用户数 |

**请求示例：**

```json
{
  "contactName": "李四",
  "contactPhone": "13900139000",
  "storageQuota": 200,
  "userQuota": 100
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "更新成功",
  "data": null
}
```

#### 4.3.4 停用/启用租户

**接口地址：** `PUT /api/tenant/{id}/status`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 租户ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| status | Integer | 是 | 状态：1-正常，0-停用 |

**请求示例：**

```json
{
  "status": 0
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "操作成功",
  "data": null
}
```

#### 4.3.5 删除租户

**接口地址：** `DELETE /api/tenant/{id}`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 租户ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "删除成功",
  "data": null
}
```

#### 4.3.6 查询租户的管理员列表

**接口地址：** `GET /api/tenant/{tenantId}/admins`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| tenantId | Long | 是 | 租户ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": [
    {
      "id": 2,
      "username": "admin01",
      "realName": "管理员01",
      "phone": "13800138000",
      "createTime": "2025-01-01 10:00:00"
    }
  ]
}
```

#### 4.3.7 为租户添加管理员

**接口地址：** `POST /api/tenant/{tenantId}/admin`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| tenantId | Long | 是 | 租户ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| username | String | 是 | 用户名，企业内唯一 |
| password | String | 是 | 初始密码，最少6位 |
| realName | String | 是 | 真实姓名 |
| phone | String | 是 | 手机号，企业内唯一 |

**请求示例：**

```json
{
  "username": "admin01",
  "password": "123456",
  "realName": "管理员01",
  "phone": "13800138000"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "添加成功",
  "data": {
    "id": 2
  }
}
```

#### 4.3.8 编辑租户管理员

**接口地址：** `PUT /api/tenant/{tenantId}/admin/{userId}`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| tenantId | Long | 是 | 租户ID |
| userId | Long | 是 | 用户ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| realName | String | 否 | 真实姓名 |
| phone | String | 否 | 手机号，企业内唯一 |

**请求示例：**

```json
{
  "realName": "管理员01修改",
  "phone": "13900139000"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "更新成功",
  "data": null
}
```

#### 4.3.9 删除租户管理员

**接口地址：** `DELETE /api/tenant/{tenantId}/admin/{userId}`

**权限：** 平台超管

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| tenantId | Long | 是 | 租户ID |
| userId | Long | 是 | 用户ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "删除成功",
  "data": null
}
```

### 4.4 用户管理接口

#### 4.4.1 创建用户

**接口地址：** `POST /api/user`

**权限：** 平台超管、企业管理员

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| username | String | 是 | 用户名，企业内唯一 |
| password | String | 是 | 初始密码，最少6位 |
| realName | String | 是 | 真实姓名 |
| phone | String | 是 | 手机号，企业内唯一 |
| roles | Array<String> | 是 | 角色列表：TENANT_ADMIN/REVIEWER/USER，企业管理员不能与其他角色并存，审查员和普通用户可以同时拥有 |

**请求示例：**

```json
{
  "username": "user01",
  "password": "123456",
  "realName": "用户01",
  "phone": "13800138001",
  "roles": ["REVIEWER", "USER"]
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "创建成功",
  "data": {
    "id": 2
  }
}
```

#### 4.4.2 查询用户列表

**接口地址：** `GET /api/user/list`

**权限：** 平台超管、企业管理员

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | Integer | 是 | 页码，从1开始 |
| pageSize | Integer | 是 | 每页数量 |
| role | String | 否 | 角色筛选：TENANT_ADMIN/REVIEWER/USER |
| status | Integer | 否 | 状态筛选：1-正常，0-停用 |
| keyword | String | 否 | 用户名关键词搜索 |

**请求示例：**

```
GET /api/user/list?page=1&pageSize=10&role=REVIEWER&status=1&keyword=user
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "records": [
      {
        "id": 2,
        "username": "user01",
        "realName": "用户01",
        "phone": "13800138001",
        "roles": ["REVIEWER", "USER"],
        "status": 1,
        "createTime": "2025-01-01 10:00:00",
        "lastLoginTime": "2025-01-01 11:00:00"
      }
    ],
    "total": 1,
    "currentPage": 1,
    "pageSize": 10
  }
}
```

#### 4.4.3 查询审查员列表

**接口地址：** `GET /api/user/reviewers`

**权限：** 普通用户（用于创建任务时选择审查员）

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": [
    {
      "id": 2,
      "realName": "审查员01"
    },
    {
      "id": 3,
      "realName": "审查员02"
    }
  ]
}
```

#### 4.4.4 更新用户

**接口地址：** `PUT /api/user/{id}`

**权限：** 平台超管、企业管理员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 用户ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| realName | String | 否 | 真实姓名 |
| phone | String | 否 | 手机号，企业内唯一 |
| roles | Array<String> | 否 | 角色列表：TENANT_ADMIN/REVIEWER/USER |

**请求示例：**

```json
{
  "realName": "用户01修改",
  "phone": "13900139001",
  "roles": ["USER"]
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "更新成功",
  "data": null
}
```

#### 4.4.5 停用/启用用户

**接口地址：** `PUT /api/user/{id}/status`

**权限：** 平台超管、企业管理员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 用户ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| status | Integer | 是 | 状态：1-正常，0-停用 |

**请求示例：**

```json
{
  "status": 0
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "操作成功",
  "data": null
}
```

#### 4.4.6 删除用户

**接口地址：** `DELETE /api/user/{id}`

**权限：** 平台超管、企业管理员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 用户ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "删除成功",
  "data": null
}
```

### 4.5 审查任务接口

#### 4.5.1 创建审查任务

**接口地址：** `POST /api/task`

**权限：** 普通用户

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| taskName | String | 是 | 任务名称，企业内唯一 |
| reviewerId | Long | 是 | 审查员ID，必须是本企业的审查员 |
| submitDesc | String | 否 | 提交说明 |

**请求示例：**

```json
{
  "taskName": "项目方案审查",
  "reviewerId": 2,
  "submitDesc": "请审查项目方案初稿"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "创建成功",
  "data": {
    "taskId": 1,
    "versionId": 1
  }
}
```

**说明：**
- 创建任务时自动创建版本v1，状态为"REVIEWING"
- 创建成功后，前端需要调用文件上传接口（4.7.1）上传PDF文件到返回的versionId
- 至少上传1个文件，任务才算完整创建

#### 4.5.2 查询我的任务列表（普通用户）

**接口地址：** `GET /api/task/my`

**权限：** 普通用户

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | Integer | 是 | 页码，从1开始 |
| pageSize | Integer | 是 | 每页数量 |
| status | String | 否 | 状态筛选：REVIEWING/APPROVED/REJECTED |
| keyword | String | 否 | 任务名称关键词搜索 |

**请求示例：**

```
GET /api/task/my?page=1&pageSize=10&status=REVIEWING&keyword=项目
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "records": [
      {
        "id": 1,
        "taskName": "项目方案审查",
        "reviewerId": 2,
        "reviewerName": "审查员01",
        "currentVersion": 1,
        "currentStatus": "REVIEWING",
        "createTime": "2025-01-01 10:00:00"
      }
    ],
    "total": 1,
    "currentPage": 1,
    "pageSize": 10
  }
}
```

#### 4.5.3 查询待审查任务列表（审查员）

**接口地址：** `GET /api/task/review`

**权限：** 审查员

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | Integer | 是 | 页码，从1开始 |
| pageSize | Integer | 是 | 每页数量 |
| status | String | 否 | 状态筛选：REVIEWING/APPROVED/REJECTED |
| keyword | String | 否 | 任务名称关键词搜索 |

**请求示例：**

```
GET /api/task/review?page=1&pageSize=10&status=REVIEWING&keyword=项目
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "records": [
      {
        "id": 1,
        "taskName": "项目方案审查",
        "creatorId": 3,
        "creatorName": "用户01",
        "currentVersion": 1,
        "currentStatus": "REVIEWING",
        "createTime": "2025-01-01 10:00:00"
      }
    ],
    "total": 1,
    "currentPage": 1,
    "pageSize": 10
  }
}
```

#### 4.5.4 查询任务详情

**接口地址：** `GET /api/task/{id}`

**权限：** 任务创建者或审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 任务ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "id": 1,
    "taskName": "项目方案审查",
    "creatorId": 3,
    "creatorName": "用户01",
    "reviewerId": 2,
    "reviewerName": "审查员01",
    "currentVersion": 1,
    "currentStatus": "REVIEWING",
    "createTime": "2025-01-01 10:00:00"
  }
}
```

### 4.6 审查版本接口

#### 4.6.1 查询任务的版本列表

**接口地址：** `GET /api/version/list/{taskId}`

**权限：** 任务创建者或审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| taskId | Long | 是 | 任务ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": [
    {
      "id": 1,
      "versionNumber": 1,
      "submitDesc": "请审查项目方案初稿",
      "submitTime": "2025-01-01 10:00:00",
      "status": "REVIEWING",
      "reviewResult": null,
      "reviewComment": null,
      "reviewerId": null,
      "reviewerName": null,
      "reviewTime": null
    }
  ]
}
```

#### 4.6.2 查询版本详情

**接口地址：** `GET /api/version/{id}`

**权限：** 任务创建者或审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 版本ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "id": 1,
    "taskId": 1,
    "taskName": "项目方案审查",
    "versionNumber": 1,
    "submitDesc": "请审查项目方案初稿",
    "submitTime": "2025-01-01 10:00:00",
    "status": "REVIEWING",
    "reviewResult": null,
    "reviewComment": null,
    "reviewerId": null,
    "reviewerName": null,
    "reviewTime": null,
    "files": [
      {
        "id": 1,
        "fileName": "项目方案.pdf",
        "filePath": "/docs/项目方案.pdf",
        "fileSize": 1048576,
        "uploadTime": "2025-01-01 10:00:00"
      }
    ]
  }
}
```

#### 4.6.3 提交新版本

**接口地址：** `POST /api/version/{taskId}`

**权限：** 任务创建者

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| taskId | Long | 是 | 任务ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| submitDesc | String | 否 | 提交说明，可说明根据审查意见做了哪些修改 |

**请求示例：**

```json
{
  "submitDesc": "根据审查意见修改了第3页内容"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "创建成功",
  "data": {
    "versionId": 2,
    "versionNumber": 2
  }
}
```

**说明：**
- 只有任务状态为"REJECTED"（已打回）时才能提交新版本
- 新版本号自动递增（v2、v3...）
- 后端会自动复制上一版本的所有文件到新版本
- 新版本状态自动设置为"REVIEWING"
- 前端可以通过文件管理接口（4.7.5）删除不需要的文件，或通过（4.7.1）上传新文件

#### 4.6.4 执行审查

**接口地址：** `POST /api/version/{id}/review`

**权限：** 审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | Long | 是 | 版本ID |

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| reviewResult | String | 是 | 审查结果：APPROVED-通过，REJECTED-打回 |
| reviewComment | String | 否 | 审查意见 |

**请求示例：**

```json
{
  "reviewResult": "APPROVED",
  "reviewComment": "方案合理，同意通过"
}
```

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "审查成功",
  "data": null
}
```

### 4.7 文件管理接口

#### 4.7.1 检查文件是否存在（MD5秒传）

**接口地址：** `GET /api/file/check-exists`

**权限：** 普通用户

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| md5 | String | 是 | 文件MD5值（32位小写） |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "exists": true,
    "minioObjectName": "1001/a3b2c1d4e5f6..."
  }
}
```

**说明：**
- 如果exists为true，表示文件已存在，可以秒传
- minioObjectName用于后续创建文件记录

#### 4.7.2 上传文件

**接口地址：** `POST /api/file/upload`

**权限：** 普通用户

**Content-Type：** `multipart/form-data`

**请求参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| versionId | Long | 是 | 版本ID |
| fileName | String | 是 | 原始文件名，如：项目方案.pdf |
| md5 | String | 是 | 文件MD5值（前端计算） |
| file | File | 是 | 文件，仅支持PDF格式，最大200MB |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "上传成功",
  "data": {
    "fileId": 1,
    "fileName": "项目方案.pdf",
    "fileSize": 1048576,
    "isNewUpload": true
  }
}
```

**说明：**
- 文件类型限制：仅支持PDF格式（.pdf）
- 文件大小限制：最大200MB
- fileName为用户上传的原始文件名，同一版本下必须唯一
- 上传前会检查租户存储配额
- isNewUpload表示是否为新上传（false表示秒传复用已有文件）
- 使用MD5去重机制，相同内容的文件在MinIO中只存储一份

#### 4.7.3 查询版本文件列表

**接口地址：** `GET /api/file/list/{versionId}`

**权限：** 任务创建者或审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| versionId | Long | 是 | 版本ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": [
    {
      "id": 1,
      "fileName": "项目方案.pdf",
      "fileSize": 1048576,
      "fileType": "application/pdf",
      "uploadTime": "2025-01-01 10:00:00"
    }
  ]
}
```

#### 4.7.4 查询版本状态（轮询使用）

**接口地址：** `GET /api/version/{versionId}/status`

**权限：** 任务创建者

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| versionId | Long | 是 | 版本ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "filesReady": true,
    "fileCount": 15
  }
}
```

**说明：**
- filesReady表示文件是否已就绪（异步复制是否完成）
- 提交新版本后，前端每2秒轮询一次，检查文件是否复制完成
- 最多轮询30次（60秒），超时提示用户刷新页面

#### 4.7.5 下载文件

**接口地址：** `GET /api/file/download/{fileId}`

**权限：** 任务创建者或审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| fileId | Long | 是 | 文件ID |

**响应数据：**

- Content-Type: `application/pdf`
- Content-Disposition: `attachment; filename="项目方案.pdf"`
- 文件二进制流

#### 4.7.6 获取文件预览URL

**接口地址：** `GET /api/file/preview/{fileId}`

**权限：** 任务创建者或审查员

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| fileId | Long | 是 | 文件ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "获取成功",
  "data": {
    "previewUrl": "http://minio:9000/review-files/1001/a3b2c1d4e5f6...?X-Amz-Algorithm=...",
    "expireTime": "2025-01-08 10:00:00"
  }
}
```

**说明：**
- previewUrl为MinIO预签名URL，有效期7天
- 前端使用PDF.js加载此URL进行预览

#### 4.7.7 删除文件

**接口地址：** `DELETE /api/file/{fileId}`

**权限：** 任务创建者（仅限REVIEWING状态的版本）

**路径参数：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| fileId | Long | 是 | 文件ID |

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "删除成功",
  "data": null
}
```

### 4.8 平台统计接口

#### 4.8.1 查询平台统计数据

**接口地址：** `GET /api/statistics/platform`

**权限：** 平台超管

**响应数据：**

```json
{
  "code": "SUCCESS",
  "message": "查询成功",
  "data": {
    "tenantCount": 10,
    "userCount": 150,
    "taskCount": 500,
    "storageUsed": 10737418240
  }
}
```

### 4.9 错误码定义

#### 4.9.1 通用错误码

| 错误码 | 说明 |
|--------|------|
| SUCCESS | 操作成功 |
| PARAM_ERROR | 参数错误 |
| UNAUTHORIZED | 未授权，需要登录 |
| FORBIDDEN | 无权限访问 |
| NOT_FOUND | 资源不存在 |
| SYSTEM_ERROR | 系统异常 |
| TOKEN_EXPIRED | Token已过期 |

#### 4.9.2 租户相关错误码

| 错误码 | 说明 |
|--------|------|
| TENANT_NAME_EXISTS | 企业名称已存在 |
| TENANT_NOT_FOUND | 租户不存在 |
| TENANT_DISABLED | 租户已停用 |
| STORAGE_QUOTA_EXCEEDED | 存储配额不足 |
| USER_QUOTA_EXCEEDED | 用户配额不足 |
| STORAGE_QUOTA_INVALID | 存储配额不能小于已使用量 |
| USER_QUOTA_INVALID | 用户配额不能小于已创建用户数 |

#### 4.9.3 用户相关错误码

| 错误码 | 说明 |
|--------|------|
| USERNAME_EXISTS | 用户名已存在 |
| PHONE_EXISTS | 手机号已存在 |
| USER_NOT_FOUND | 用户不存在 |
| USER_DISABLED | 用户已停用 |
| PASSWORD_ERROR | 密码错误 |
| OLD_PASSWORD_ERROR | 原密码错误 |
| LOGIN_FAILED_LOCKED | 登录失败次数过多，账号已锁定 |

#### 4.9.4 任务相关错误码

| 错误码 | 说明 |
|--------|------|
| TASK_NAME_EXISTS | 任务名称已存在 |
| TASK_NOT_FOUND | 任务不存在 |
| REVIEWER_NOT_FOUND | 审查员不存在 |
| REVIEWER_INVALID | 审查员不属于本企业 |
| TASK_STATUS_INVALID | 任务状态不允许此操作 |
| NOT_TASK_CREATOR | 不是任务创建者 |
| NOT_TASK_REVIEWER | 不是任务审查员 |

#### 4.9.5 版本相关错误码

| 错误码 | 说明 |
|--------|------|
| VERSION_NOT_FOUND | 版本不存在 |
| VERSION_REVIEWED | 版本已审查完成 |
| VERSION_STATUS_INVALID | 版本状态不允许此操作 |
| NO_FILES_UPLOADED | 未上传任何文件 |
| FILE_COUNT_INVALID | 至少需要1个文件 |

#### 4.9.6 文件相关错误码

| 错误码 | 说明 |
|--------|------|
| FILE_NOT_FOUND | 文件不存在 |
| FILE_TYPE_INVALID | 文件类型不支持，仅支持PDF |
| FILE_SIZE_EXCEEDED | 文件大小超过限制（200MB） |
| FILE_PATH_EXISTS | 文件路径已存在 |
| FILE_UPLOAD_FAILED | 文件上传失败 |
| FILE_DELETE_FAILED | 文件删除失败 |
| MINIO_ERROR | 文件存储服务异常 |

## 5. 部署方案

### 5.1 部署环境说明

#### 5.1.1 服务器配置要求

**推荐配置：**
- CPU: 2核
- 内存: 2GB（最低配置，支持10-20并发用户）
- 磁盘: 50GB以上（根据文件存储需求调整）
- 操作系统: Linux (CentOS 7+/Ubuntu 18.04+)

**说明：**
- 本部署方案已针对2核2GB服务器进行优化
- 所有容器资源限制、JVM参数、数据库配置均基于2GB内存设计
- 如并发用户超过20人或性能不足，建议升级到2核4GB配置
- 升级到4GB时，可适当调整容器内存限制和JVM参数以获得更好性能

**软件要求：**
- Docker 20.10+
- Docker Compose 2.0+

#### 5.1.2 资源分配方案

本部署方案采用Docker容器化部署，各容器资源分配如下：

| 服务 | 内存限制 | 内存预留 | CPU限制 | 说明 |
|------|---------|---------|---------|------|
| MySQL | 400MB | 300MB | 1.0核 | 数据库服务 |
| Redis | 100MB | 50MB | 0.5核 | 缓存服务 |
| MinIO | 300MB | 200MB | 0.5核 | 对象存储 |
| Backend | 700MB | 512MB | 1.5核 | 后端应用 |
| Frontend | 100MB | 50MB | 0.5核 | Nginx前端 |
| **总计** | **1600MB** | **1112MB** | **4.0核** | 系统保留~448MB |

### 5.2 Docker容器化部署

#### 5.2.1 部署架构

```
┌─────────────────────────────────────────┐
│           Nginx (端口80/443)             │
│     - 反向代理                            │
│     - 前端静态资源服务                     │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│       Spring Boot (端口8080)            │
│     - 后端API服务                         │
└─────────────────────────────────────────┘
              ↓
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   MySQL     │  │   Redis     │  │   MinIO     │
│  (端口3306) │  │  (端口6379) │  │  (端口9000) │
│  - 数据库   │  │  - 缓存     │  │  - 对象存储 │
└─────────────┘  └─────────────┘  └─────────────┘
```

#### 5.2.2 Docker Compose配置

**docker-compose.yml：**

```yaml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: review-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root123456
      MYSQL_DATABASE: review_system
      MYSQL_USER: review_user
      MYSQL_PASSWORD: review123456
      TZ: Asia/Shanghai
    ports:
      - "3306:3306"
    volumes:
      - ./data/mysql:/var/lib/mysql
      - ./init/mysql:/docker-entrypoint-initdb.d
      - ./config/mysql/my.cnf:/etc/mysql/conf.d/my.cnf
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 400M
        reservations:
          cpus: '0.5'
          memory: 300M
    networks:
      - review-network

  # MinIO对象存储
  minio:
    image: minio/minio:latest
    container_name: review-minio
    restart: always
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
      TZ: Asia/Shanghai
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - ./data/minio:/data
    command: server /data --console-address ":9001"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 300M
        reservations:
          cpus: '0.25'
          memory: 200M
    networks:
      - review-network

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: review-redis
    restart: always
    environment:
      TZ: Asia/Shanghai
    ports:
      - "6379:6379"
    volumes:
      - ./data/redis:/data
      - ./config/redis/redis.conf:/etc/redis/redis.conf
    command: redis-server /etc/redis/redis.conf
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 100M
        reservations:
          cpus: '0.1'
          memory: 50M
    networks:
      - review-network

  # 后端服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: review-backend
    restart: always
    environment:
      SPRING_PROFILES_ACTIVE: prod
      DB_HOST: mysql
      DB_PORT: 3306
      DB_NAME: review_system
      DB_USER: review_user
      DB_PASSWORD: review123456
      MINIO_ENDPOINT: http://minio:9000
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
      REDIS_HOST: redis
      REDIS_PORT: 6379
      TZ: Asia/Shanghai
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - minio
      - redis
    volumes:
      - ./logs/backend:/app/logs
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 700M
        reservations:
          cpus: '0.5'
          memory: 512M
    networks:
      - review-network

  # 前端+Nginx
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: review-frontend
    restart: always
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 100M
        reservations:
          cpus: '0.1'
          memory: 50M
    networks:
      - review-network

networks:
  review-network:
    driver: bridge

volumes:
  mysql-data:
  minio-data:
  redis-data:
```

#### 5.2.3 后端Dockerfile

**backend/Dockerfile：**

```dockerfile
# 第一阶段：构建
FROM maven:3.8-openjdk-8 AS builder

WORKDIR /app

# 复制pom.xml并下载依赖
COPY pom.xml .
RUN mvn dependency:go-offline -B

# 复制源代码并构建
COPY src ./src
RUN mvn clean package -DskipTests

# 第二阶段：运行
FROM openjdk:8-jre-slim

WORKDIR /app

# 复制构建好的jar包
COPY --from=builder /app/target/review-system-1.0.0.jar app.jar

# 暴露端口
EXPOSE 8080

# 启动命令（针对2核2G服务器优化）
ENTRYPOINT ["java", \
    "-jar", \
    "-Xms256m", \
    "-Xmx512m", \
    "-XX:+UseG1GC", \
    "-XX:MaxGCPauseMillis=200", \
    "-XX:+HeapDumpOnOutOfMemoryError", \
    "-XX:HeapDumpPath=/app/logs/", \
    "app.jar"]
```

#### 5.2.4 前端Dockerfile

**frontend/Dockerfile：**

```dockerfile
# 第一阶段：构建
FROM node:16-alpine AS builder

WORKDIR /app

# 复制package.json并安装依赖
COPY package*.json ./
RUN npm install

# 复制源代码并构建
COPY . .
RUN npm run build

# 第二阶段：Nginx
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制Nginx配置
COPY nginx.conf /etc/nginx/nginx.conf

# 暴露端口
EXPOSE 80 443

# 启动Nginx
CMD ["nginx", "-g", "daemon off;"]
```

#### 5.2.5 Nginx配置

**nginx/nginx.conf：**

```nginx
user nginx;
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript
               application/json application/javascript application/xml+rss
               application/rss+xml font/truetype font/opentype
               application/vnd.ms-fontobject image/svg+xml;

    # 上游后端服务
    upstream backend {
        server backend:8080;
    }

    # HTTP服务器
    server {
        listen 80;
        server_name localhost;

        # 前端静态资源
        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
        }

        # 后端API代理
        location /api/ {
            proxy_pass http://backend/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # 超时设置
            proxy_connect_timeout 60s;
            proxy_send_timeout 300s;
            proxy_read_timeout 300s;

            # 文件上传大小限制
            client_max_body_size 200M;
        }

        # 静态资源缓存
        location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
            root /usr/share/nginx/html;
            expires 7d;
            add_header Cache-Control "public, immutable";
        }
    }

    # HTTPS服务器（可选）
    # server {
    #     listen 443 ssl http2;
    #     server_name your-domain.com;
    #
    #     ssl_certificate /etc/nginx/ssl/cert.pem;
    #     ssl_certificate_key /etc/nginx/ssl/key.pem;
    #     ssl_protocols TLSv1.2 TLSv1.3;
    #     ssl_ciphers HIGH:!aNULL:!MD5;
    #
    #     location / {
    #         root /usr/share/nginx/html;
    #         index index.html;
    #         try_files $uri $uri/ /index.html;
    #     }
    #
    #     location /api/ {
    #         proxy_pass http://backend/api/;
    #         # ... 其他配置同HTTP
    #     }
    # }
}
```

#### 5.2.6 MySQL优化配置

**config/mysql/my.cnf（针对2核2G服务器优化）：**

```ini
[mysqld]
# 基础配置
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci

# 内存优化（总内存约300M）
innodb_buffer_pool_size=200M          # InnoDB缓冲池，最重要的配置
innodb_log_buffer_size=8M              # 日志缓冲区
key_buffer_size=16M                    # MyISAM索引缓冲（基本不用）
query_cache_size=0                     # 禁用查询缓存（MySQL 8.0已移除）
tmp_table_size=16M                     # 内存临时表大小
max_heap_table_size=16M                # 堆表最大大小

# 连接配置
max_connections=100                    # 最大连接数（根据实际并发调整）
max_connect_errors=100                 # 最大错误连接数
connect_timeout=10                     # 连接超时时间

# InnoDB优化
innodb_flush_log_at_trx_commit=2      # 性能优先（每秒刷盘，可能丢失1秒数据）
innodb_flush_method=O_DIRECT           # 避免双重缓冲
innodb_io_capacity=200                 # IO能力（根据磁盘性能调整）
innodb_read_io_threads=2               # 读IO线程
innodb_write_io_threads=2              # 写IO线程

# 日志配置
slow_query_log=1                       # 开启慢查询日志
slow_query_log_file=/var/log/mysql/slow.log
long_query_time=2                      # 慢查询阈值2秒

# 二进制日志（建议开启，用于备份恢复）
log_bin=/var/log/mysql/mysql-bin
expire_logs_days=7                     # 日志保留7天
max_binlog_size=100M                   # 单个日志文件最大100M
```

#### 5.2.7 Redis配置

**config/redis/redis.conf（针对2核2G服务器优化）：**

```conf
# 网络配置
bind 0.0.0.0
protected-mode yes
port 6379

# 内存配置
maxmemory 80mb                         # 最大内存80MB（容器限制100M）
maxmemory-policy allkeys-lru           # 内存满时删除最少使用的key

# 持久化配置（RDB方式）
save 900 1                             # 15分钟内至少1次写入，保存快照
save 300 10                            # 5分钟内至少10次写入，保存快照
save 60 10000                          # 1分钟内至少10000次写入，保存快照
stop-writes-on-bgsave-error yes        # 后台保存失败时停止写入
rdbcompression yes                     # 压缩RDB文件
rdbchecksum yes                        # 校验RDB文件
dbfilename dump.rdb                    # RDB文件名
dir /data                              # 数据目录

# AOF配置（可选，更安全但性能较低）
appendonly no                          # 不开启AOF（小内存服务器推荐关闭）

# 性能优化
timeout 300                            # 客户端空闲超时（秒）
tcp-keepalive 60                       # TCP保活时间
maxclients 100                         # 最大客户端连接数

# 日志
loglevel notice
logfile ""

# 其他
databases 16                           # 数据库数量
```

### 5.3 数据库初始化

#### 5.3.1 数据库初始化脚本

**init/mysql/init.sql：**

```sql
-- 创建数据库（如果不存在）
CREATE DATABASE IF NOT EXISTS review_system
CHARACTER SET utf8mb4
COLLATE utf8mb4_unicode_ci;

USE review_system;

-- 租户表
CREATE TABLE IF NOT EXISTS tenant (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_name VARCHAR(100) NOT NULL UNIQUE COMMENT '企业名称',
    contact_name VARCHAR(50) NOT NULL COMMENT '联系人姓名',
    contact_phone VARCHAR(20) NOT NULL COMMENT '联系电话',
    storage_quota BIGINT NOT NULL DEFAULT 107374182400 COMMENT '存储配额（字节）',
    storage_used BIGINT NOT NULL DEFAULT 0 COMMENT '已用存储（字节）',
    user_quota INT NOT NULL DEFAULT 50 COMMENT '用户数量配额',
    user_count INT NOT NULL DEFAULT 0 COMMENT '已创建用户数',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：1-正常，0-停用',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    deleted TINYINT NOT NULL DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除',
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='租户表';

-- 用户表
CREATE TABLE IF NOT EXISTS user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NULL COMMENT '租户ID，平台超管为NULL',
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    password VARCHAR(100) NOT NULL COMMENT '密码（BCrypt加密）',
    real_name VARCHAR(50) NOT NULL COMMENT '真实姓名',
    phone VARCHAR(20) NULL COMMENT '手机号',
    role_platform_admin TINYINT NOT NULL DEFAULT 0 COMMENT '平台超管角色：1-是，0-否',
    role_tenant_admin TINYINT NOT NULL DEFAULT 0 COMMENT '企业管理员角色：1-是，0-否',
    role_reviewer TINYINT NOT NULL DEFAULT 0 COMMENT '审查员角色：1-是，0-否',
    role_user TINYINT NOT NULL DEFAULT 0 COMMENT '普通用户角色：1-是，0-否',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：1-正常，0-停用',
    last_login_time DATETIME NULL COMMENT '最后登录时间',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    deleted TINYINT NOT NULL DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除',
    UNIQUE KEY uk_tenant_username (tenant_id, username),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';

-- 审查任务表
CREATE TABLE IF NOT EXISTS review_task (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    task_name VARCHAR(200) NOT NULL COMMENT '任务名称',
    creator_id BIGINT NOT NULL COMMENT '创建人ID',
    reviewer_id BIGINT NOT NULL COMMENT '审查员ID',
    current_version INT NOT NULL DEFAULT 1 COMMENT '当前版本号',
    current_status VARCHAR(20) NOT NULL DEFAULT 'REVIEWING' COMMENT '当前状态',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    deleted TINYINT NOT NULL DEFAULT 0 COMMENT '逻辑删除',
    UNIQUE KEY uk_tenant_task_name (tenant_id, task_name),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_creator_id (creator_id),
    INDEX idx_reviewer_id (reviewer_id),
    INDEX idx_current_status (current_status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='审查任务表';

-- 审查版本表
CREATE TABLE IF NOT EXISTS review_version (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    task_id BIGINT NOT NULL COMMENT '任务ID',
    version_number INT NOT NULL COMMENT '版本号',
    submit_desc TEXT NULL COMMENT '提交说明',
    submit_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '提交时间',
    status VARCHAR(20) NOT NULL DEFAULT 'REVIEWING' COMMENT '审查状态',
    review_result VARCHAR(20) NULL COMMENT '审查结果',
    review_comment TEXT NULL COMMENT '审查意见',
    reviewer_id BIGINT NULL COMMENT '审查人ID',
    review_time DATETIME NULL COMMENT '审查时间',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    deleted TINYINT NOT NULL DEFAULT 0 COMMENT '逻辑删除',
    UNIQUE KEY uk_task_version (task_id, version_number),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_task_id (task_id),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='审查版本表';

-- 文件表
CREATE TABLE IF NOT EXISTS review_file (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    version_id BIGINT NOT NULL COMMENT '版本ID',
    file_name VARCHAR(255) NOT NULL COMMENT '原始文件名',
    file_path VARCHAR(500) NOT NULL COMMENT '项目内相对路径',
    file_size BIGINT NOT NULL COMMENT '文件大小（字节）',
    file_type VARCHAR(50) NOT NULL COMMENT '文件扩展名',
    file_md5 VARCHAR(32) NOT NULL COMMENT '文件MD5值，用于去重',
    minio_object_name VARCHAR(500) NOT NULL COMMENT 'MinIO对象名（格式：tenant_id/md5）',
    upload_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '上传时间',
    deleted TINYINT NOT NULL DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除',
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_version_id (version_id),
    INDEX idx_file_md5 (file_md5),
    INDEX idx_tenant_md5_deleted (tenant_id, file_md5, deleted),
    UNIQUE KEY uk_version_filepath (version_id, file_path)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='文件表';

-- 插入平台超管账号（密码：admin123，BCrypt加密）
INSERT INTO user (tenant_id, username, password, real_name, role_platform_admin, status)
VALUES (NULL, 'admin', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iAt6Z5EH', '平台管理员', 1, 1);
```

### 5.4 部署流程

#### 5.4.1 安装Docker和Docker Compose

```bash
# CentOS
sudo yum install -y docker docker-compose
sudo systemctl start docker
sudo systemctl enable docker

# Ubuntu
sudo apt-get update
sudo apt-get install -y docker.io docker-compose
sudo systemctl start docker
sudo systemctl enable docker
```

#### 5.4.2 创建项目目录

```bash
mkdir -p /opt/review-system
cd /opt/review-system

# 创建必要的目录
mkdir -p data/mysql data/minio data/redis logs/backend init/mysql config/mysql config/redis nginx/ssl
```

#### 5.4.3 上传项目文件

将以下文件上传到 `/opt/review-system` 目录：
- `docker-compose.yml` - Docker编排配置
- `backend/` - 后端代码目录（包含Dockerfile）
- `frontend/` - 前端代码目录（包含Dockerfile）
- `init/mysql/init.sql` - 数据库初始化脚本
- `config/mysql/my.cnf` - MySQL优化配置
- `config/redis/redis.conf` - Redis配置
- `nginx/nginx.conf` - Nginx配置

#### 5.4.4 启动服务

```bash
# 启动所有容器
docker-compose up -d

# 查看容器状态
docker-compose ps

# 查看日志
docker-compose logs -f
```

#### 5.4.5 验证部署

```bash
# 检查MySQL
docker exec -it review-mysql mysql -uroot -proot123456 -e "SHOW DATABASES;"

# 检查MinIO
curl http://localhost:9000/minio/health/live

# 检查后端
curl http://localhost:8080/api/health

# 检查前端
curl http://localhost
```

#### 5.4.6 常用运维命令

**停止服务：**
```bash
docker-compose stop
```

**重启服务：**
```bash
docker-compose restart
```

**查看日志：**
```bash
docker-compose logs -f backend
docker-compose logs -f frontend
```

**备份数据：**
```bash
# 备份MySQL
docker exec review-mysql mysqldump -uroot -proot123456 review_system > backup.sql

# 备份MinIO
tar -czf minio-backup.tar.gz data/minio/
```

**恢复数据：**
```bash
# 恢复MySQL
docker exec -i review-mysql mysql -uroot -proot123456 review_system < backup.sql

# 恢复MinIO
tar -xzf minio-backup.tar.gz -C data/
```

### 5.5 性能优化建议

#### 5.5.1 资源分配总览

**2核2G服务器资源分配：**
- MySQL: 400MB (限制) / 300MB (预留)
- MinIO: 300MB (限制) / 200MB (预留)
- Redis: 100MB (限制) / 50MB (预留)
- Backend: 700MB (限制) / 512MB (预留)
- Frontend/Nginx: 100MB (限制) / 50MB (预留)
- 系统保留: ~448MB

**总计：** 1600MB容器使用，448MB系统保留

#### 5.5.2 后端应用优化

**1. Spring Boot连接池配置（application.yml）：**
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 10        # 2G内存降低连接池大小
      minimum-idle: 3               # 最小空闲连接
      connection-timeout: 30000     # 连接超时30秒
      idle-timeout: 600000          # 空闲连接超时10分钟
      max-lifetime: 1800000         # 连接最大存活时间30分钟

  # Redis连接池
  redis:
    lettuce:
      pool:
        max-active: 8               # 最大活动连接
        max-idle: 4                 # 最大空闲连接
        min-idle: 2                 # 最小空闲连接
```

**2. JVM参数（已在Dockerfile配置）：**
- `-Xms256m -Xmx512m`：堆内存256M-512M
- `-XX:+UseG1GC`：使用G1垃圾收集器
- `-XX:MaxGCPauseMillis=200`：最大GC暂停时间200ms

**3. 异步处理优化：**
```yaml
# 线程池配置
spring:
  task:
    execution:
      pool:
        core-size: 2              # 核心线程数（与CPU核心数一致）
        max-size: 4               # 最大线程数
        queue-capacity: 100       # 队列容量
        keep-alive: 60s           # 线程空闲保持时间
```

**4. 文件上传优化：**
```yaml
spring:
  servlet:
    multipart:
      max-file-size: 200MB        # 单文件最大200MB
      max-request-size: 200MB     # 请求最大200MB
      file-size-threshold: 10MB   # 超过10MB写入磁盘临时文件
```

#### 5.5.3 数据库优化

**1. 索引优化：**
- 确保所有外键都有索引
- 查询条件字段添加索引（tenant_id, status等）
- 联合索引遵循最左前缀原则

**2. 查询优化：**
- 分页查询限制每页最多100条
- 避免SELECT *，只查询需要的字段
- 批量操作使用批量插入/更新

**3. 慢查询监控：**
- 已配置慢查询日志，阈值2秒
- 定期检查 `/var/log/mysql/slow.log`

#### 5.5.4 Redis缓存策略

**1. 缓存内容：**
- 用户登录信息（Token，30分钟过期）
- 登录失败计数（30分钟过期）
- 租户存储统计（实时计数，每分钟同步数据库）

**2. 缓存Key设计：**
```
login:token:{userId}           # 登录Token
login:fail:{username}          # 登录失败次数
tenant:storage:{tenantId}      # 租户存储使用量
```

**3. 内存控制：**
- 最大内存80MB
- LRU淘汰策略
- 定期持久化到磁盘

#### 5.5.5 MinIO优化

**1. 文件去重：**
- 使用MD5作为对象名
- 同一文件只存储一份
- 大幅降低存储空间占用

**2. 访问优化：**
- 启用预签名URL（有效期1小时）
- 减少直接访问MinIO的压力

#### 5.5.6 Nginx优化

**1. Worker进程配置：**
```nginx
worker_processes 2;              # 与CPU核心数一致
worker_connections 512;          # 2G内存降低连接数
```

**2. 缓冲区优化：**
```nginx
client_body_buffer_size 10M;     # 请求体缓冲
client_max_body_size 200M;       # 最大请求体（文件上传）
```

**3. Gzip压缩：**
- 已启用，压缩级别6
- 压缩文本类文件，减少传输量

#### 5.5.7 性能预期

**并发能力：**
- 10-20个并发用户：流畅运行
- 20-50个并发用户：可接受，响应略慢
- 50+并发用户：建议升级到4G内存

**响应时间：**
- 普通查询：< 200ms
- 文件上传（10MB）：< 3s
- 文件下载（10MB）：< 2s
- 版本创建（复制文件）：异步处理，< 5s

### 5.6 监控与告警

#### 5.6.1 日志管理

**后端日志配置（logback-spring.xml）：**

```xml
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

#### 5.6.2 健康检查

**后端健康检查接口：**

```java
@RestController
@RequestMapping("/api/health")
public class HealthController {

    @GetMapping
    public String health() {
        return "OK";
    }
}
```

**Docker健康检查配置：**

```yaml
services:
  backend:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## 6. 开发规范

### 6.1 代码规范

#### 6.1.1 Java代码规范

**命名规范：**

1. **类名**：使用大驼峰命名法（PascalCase）
   ```java
   public class UserService { }
   public class TenantController { }
   ```

2. **方法名和变量名**：使用小驼峰命名法（camelCase）
   ```java
   public void createUser() { }
   private String userName;
   ```

3. **常量**：使用全大写加下划线
   ```java
   public static final String DEFAULT_PASSWORD = "123456";
   public static final int MAX_FILE_SIZE = 200 * 1024 * 1024;
   ```

4. **包名**：全小写，多级包用点分隔
   ```java
   com.review.controller
   com.review.service.impl
   ```

**注释规范：**

1. **类注释**：
   ```java
   /**
    * 用户服务类
    *
    * @author system
    * @since 2025-01-01
    */
   public class UserService { }
   ```

2. **方法注释**：
   ```java
   /**
    * 创建用户
    *
    * @param request 用户创建请求
    * @return 用户ID
    * @throws BusinessException 业务异常
    */
   public Long createUser(UserCreateRequest request) { }
   ```

3. **关键逻辑注释**：
   ```java
   // 检查存储配额是否充足
   if (tenant.getStorageUsed() + fileSize > tenant.getStorageQuota()) {
       throw new BusinessException("存储空间不足");
   }
   ```

**代码格式：**

1. **缩进**：使用4个空格
2. **每行最大长度**：120个字符
3. **空行**：方法之间空一行，逻辑块之间空一行
4. **导入**：按字母顺序排列，删除未使用的导入

#### 6.1.2 Vue代码规范

**命名规范：**

1. **组件名**：使用大驼峰命名法
   ```vue
   <!-- TaskList.vue -->
   <script>
   export default {
     name: 'TaskList'
   }
   </script>
   ```

2. **变量和方法**：使用小驼峰命名法
   ```javascript
   data() {
     return {
       taskList: [],
       currentPage: 1
     }
   },
   methods: {
     fetchTaskList() { }
   }
   ```

3. **常量**：使用全大写加下划线
   ```javascript
   const MAX_FILE_SIZE = 200 * 1024 * 1024
   const FILE_TYPES = ['pdf']
   ```

**组件结构顺序：**

```vue
<template>
  <!-- 模板 -->
</template>

<script>
export default {
  name: 'ComponentName',
  components: { },
  props: { },
  data() { },
  computed: { },
  watch: { },
  created() { },
  mounted() { },
  methods: { }
}
</script>

<style scoped>
/* 样式 */
</style>
```

**注释规范：**

```javascript
/**
 * 获取任务列表
 */
async fetchTaskList() {
  // 显示加载状态
  this.loading = true

  try {
    // 调用API获取数据
    const res = await taskApi.getTaskList(this.queryParams)
    this.taskList = res.data.records
  } catch (error) {
    this.$message.error('获取任务列表失败')
  } finally {
    this.loading = false
  }
}
```

### 6.2 数据库规范

#### 6.2.1 表设计规范

1. **表名**：小写字母加下划线，使用单数形式
   - 正确：`review_task`
   - 错误：`ReviewTasks`

2. **字段名**：小写字母加下划线
   - 正确：`tenant_id`, `create_time`
   - 错误：`TenantId`, `createTime`

3. **主键**：统一使用 `id`，类型为 `BIGINT AUTO_INCREMENT`

4. **必备字段**：
   - `create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP`
   - `update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`
   - `deleted TINYINT NOT NULL DEFAULT 0`

5. **外键字段**：以 `_id` 结尾，如 `tenant_id`, `user_id`

#### 6.2.2 索引规范

1. **主键索引**：每张表必须有主键
2. **唯一索引**：业务唯一字段添加唯一索引
   - 例如：`UNIQUE KEY uk_tenant_username (tenant_id, username)`
3. **普通索引**：经常用于查询条件的字段
   - 例如：`INDEX idx_status (status)`
4. **联合索引**：遵循最左前缀原则

#### 6.2.3 SQL编写规范

1. **查询规范**：
   ```sql
   -- 正确：指定字段
   SELECT id, task_name, status FROM review_task WHERE tenant_id = 1
   
   -- 错误：使用*
   SELECT * FROM review_task
   ```

2. **分页查询**：使用 `LIMIT` 和 `OFFSET`
   ```sql
   SELECT * FROM review_task
   WHERE deleted = 0
   ORDER BY create_time DESC
   LIMIT 10 OFFSET 0
   ```

3. **避免N+1查询**：使用JOIN或批量查询
   ```sql
   -- 正确：使用JOIN
   SELECT t.*, u.real_name as creator_name
   FROM review_task t
   LEFT JOIN user u ON t.creator_id = u.id
   
   -- 错误：先查任务，再循环查用户
   ```

### 6.3 API接口规范

#### 6.3.1 URL规范

1. **使用RESTful风格**：
   - GET：查询
   - POST：创建
   - PUT：更新
   - DELETE：删除

2. **URL示例**：
   ```
   GET    /api/task          查询任务列表
   GET    /api/task/{id}     查询任务详情
   POST   /api/task          创建任务
   PUT    /api/task/{id}     更新任务
   DELETE /api/task/{id}     删除任务
   ```

3. **避免在URL中使用动词**：
   - 正确：`POST /api/task`
   - 错误：`POST /api/createTask`

#### 6.3.2 请求参数规范

1. **GET请求**：参数放在URL中
   ```
   GET /api/task/list?page=1&pageSize=10&status=REVIEWING
   ```

2. **POST/PUT请求**：参数放在Body中，使用JSON格式
   ```json
   {
     "taskName": "项目方案审查",
     "reviewerId": 2
   }
   ```

3. **路径参数**：使用 `{id}` 形式
   ```
   GET /api/task/{id}
   DELETE /api/file/{fileId}
   ```

#### 6.3.3 响应规范

1. **统一响应格式**：
   ```json
   {
     "code": "SUCCESS",
     "message": "操作成功",
     "data": { }
   }
   ```

2. **HTTP状态码**：
   - 200：成功
   - 400：参数错误
   - 401：未授权
   - 403：无权限
   - 404：资源不存在
   - 500：服务器错误

### 6.4 Git规范

#### 6.4.1 分支管理

1. **主分支**：
   - `main`：生产环境分支，只接受合并
   - `develop`：开发分支，日常开发基础

2. **功能分支**：
   - 命名：`feature/功能名称`
   - 例如：`feature/user-management`

3. **修复分支**：
   - 命名：`bugfix/问题描述`
   - 例如：`bugfix/file-upload-error`

4. **热修复分支**：
   - 命名：`hotfix/问题描述`
   - 从main分支创建，修复后合并到main和develop

#### 6.4.2 提交规范

**提交消息格式**：

```
<type>: <subject>

<body>
```

**Type类型**：
- `feat`：新功能
- `fix`：修复bug
- `docs`：文档更新
- `style`：代码格式调整
- `refactor`：重构
- `test`：测试相关
- `chore`：构建/工具相关

**示例**：

```
feat: 实现文件上传功能

- 添加文件上传接口
- 集成MinIO对象存储
- 实现存储配额检查
```

```
fix: 修复文件下载时文件名乱码问题

使用URLEncoder对文件名进行编码
```

### 6.5 测试规范

#### 6.5.1 单元测试

**测试类命名**：`被测试类名 + Test`
```java
public class UserServiceTest { }
```

**测试方法命名**：`test + 方法名 + 测试场景`
```java
@Test
public void testCreateUser_Success() { }

@Test
public void testCreateUser_DuplicateUsername() { }
```

**测试覆盖率要求**：
- Service层：80%以上
- Controller层：60%以上
- Util工具类：90%以上

#### 6.5.2 集成测试

1. **数据库测试**：使用H2内存数据库或测试数据库
2. **API测试**：使用MockMvc或Postman
3. **文件上传测试**：使用Mock MinIO或测试环境

### 6.6 日志规范

#### 6.6.1 日志级别

1. **ERROR**：错误信息，需要立即处理
   ```java
   log.error("创建用户失败，用户名：{}", username, e);
   ```

2. **WARN**：警告信息，可能存在问题
   ```java
   log.warn("存储空间使用率超过80%，租户ID：{}", tenantId);
   ```

3. **INFO**：重要业务流程
   ```java
   log.info("用户登录成功，用户名：{}", username);
   ```

4. **DEBUG**：调试信息
   ```java
   log.debug("查询参数：{}", queryParams);
   ```

#### 6.6.2 日志内容规范

1. **包含关键信息**：用户ID、租户ID、操作类型等
   ```java
   log.info("创建任务成功，租户ID：{}，创建人ID：{}，任务ID：{}",
            tenantId, creatorId, taskId);
   ```

2. **避免敏感信息**：不记录密码、Token等
   ```java
   // 错误
   log.info("用户登录，密码：{}", password);
   
   // 正确
   log.info("用户登录，用户名：{}", username);
   ```

3. **异常日志**：记录完整堆栈
   ```java
   try {
       // 业务逻辑
   } catch (Exception e) {
       log.error("文件上传失败，文件名：{}", fileName, e);
   }
   ```

### 6.7 安全规范

#### 6.7.1 认证授权

1. **所有API必须验证Token**（除登录接口）
2. **使用@PreAuthorize注解控制权限**
3. **敏感操作需要二次验证**

#### 6.7.2 输入验证

1. **后端必须验证所有输入参数**
   ```java
   @NotBlank(message = "任务名称不能为空")
   @Size(max = 200, message = "任务名称不能超过200个字符")
   private String taskName;
   ```

2. **文件上传验证**：
   - 文件类型验证
   - 文件大小验证
   - 文件名验证（防止路径穿越）

3. **SQL注入防护**：使用参数化查询

#### 6.7.3 数据安全

1. **密码加密**：使用BCrypt
2. **敏感数据加密**：如手机号、身份证等
3. **传输加密**：生产环境使用HTTPS

### 6.8 性能规范

#### 6.8.1 数据库性能

1. **避免全表扫描**：查询条件必须使用索引
2. **分页查询**：大数据量查询必须分页
3. **批量操作**：多条数据插入使用批量插入

#### 6.8.2 接口性能

1. **响应时间要求**：
   - 查询接口：< 500ms
   - 创建/更新接口：< 1s
   - 文件上传接口：视文件大小而定

2. **异步处理**：
   - 文件复制操作
   - 数据统计

3. **缓存使用**：
   - 用户信息缓存
   - 租户信息缓存
   - 字典数据缓存

### 6.9 文档规范

#### 6.9.1 代码文档

1. **README.md**：项目介绍、快速开始、部署说明
2. **API文档**：使用 Knife4j 4.1.0（基于 Swagger/OpenAPI 2.0）自动生成
   - 访问地址：http://localhost:8080/api/doc.html
   - 提供美观的中文界面和在线调试功能
3. **数据库文档**：表结构说明、ER图

#### 6.9.2 接口文档

使用 Swagger 注解（Knife4j 兼容）：

```java
@Api(tags = "任务管理")
@RestController
@RequestMapping("/api/task")
public class TaskController {

    @ApiOperation("创建任务")
    @PostMapping
    public Result<Long> createTask(@RequestBody @Valid TaskCreateRequest request) {
        return Result.success(taskService.createTask(request));
    }
}
```

---

**文档结束**
